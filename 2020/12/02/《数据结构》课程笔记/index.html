<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/mine/DangoCreatures_plain.svg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/mine/DangoCreatures_plain.svg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="《数据结构》课程笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="《数据结构》课程笔记">
<meta property="og:url" content="http://example.com/2020/12/02/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Ponster&#39;s Blog">
<meta property="og:description" content="《数据结构》课程笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2020/12/02/medias/images/notes/p10.png">
<meta property="og:image" content="http://example.com/2020/12/02/medias/images/notes/p11.png">
<meta property="og:image" content="http://example.com/2020/12/02/medias/images/notes/p2.png">
<meta property="og:image" content="http://example.com/2020/12/02/medias/images/notes/p3.png">
<meta property="og:image" content="http://example.com/2020/12/02/medias/images/notes/p1.png">
<meta property="og:image" content="http://example.com/2020/12/02/medias/images/notes/p4.png">
<meta property="og:image" content="http://example.com/2020/12/02/medias/images/notes/p5.png">
<meta property="og:image" content="http://example.com/2020/12/02/medias/images/notes/p6.png">
<meta property="og:image" content="http://example.com/2020/12/02/medias/images/notes/p7.png">
<meta property="og:image" content="http://example.com/2020/12/02/medias/images/notes/p8.png">
<meta property="og:image" content="http://example.com/2020/medias/images/notes/p9.png">
<meta property="og:image" content="http://example.com/2020/12/02/medias/images/notes/p12.png">
<meta property="og:image" content="http://example.com/2020/12/02/medias/images/notes/p13.png">
<meta property="og:image" content="http://example.com/2020/12/02/medias/images/notes/p14.png">
<meta property="og:image" content="http://example.com/2020/12/02/medias/images/notes/p15.png">
<meta property="og:image" content="http://example.com/2020/12/02/medias/images/notes/p16.png">
<meta property="og:image" content="http://example.com/2020/12/02/medias/images/notes/p17.png">
<meta property="og:image" content="http://example.com/2020/12/02/medias/images/notes/p18.png">
<meta property="og:image" content="http://example.com/2020/12/02/medias/images/notes/p19.png">
<meta property="article:published_time" content="2020-12-02T07:31:11.961Z">
<meta property="article:modified_time" content="2020-12-11T10:31:32.244Z">
<meta property="article:author" content="Ponster">
<meta property="article:tag" content="-[数据结构] -[Java]">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2020/12/02/medias/images/notes/p10.png">

<link rel="canonical" href="http://example.com/2020/12/02/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>《数据结构》课程笔记 | Ponster's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ponster's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/02/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mine/Attack.png">
      <meta itemprop="name" content="Ponster">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ponster's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《数据结构》课程笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-02 15:31:11" itemprop="dateCreated datePublished" datetime="2020-12-02T15:31:11+08:00">2020-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-11 18:31:32" itemprop="dateModified" datetime="2020-12-11T18:31:32+08:00">2020-12-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="数据结构课程笔记">《数据结构》课程笔记</h1>
<a id="more"></a>
<!-- TOC -->
<ul>
<li><a href="#数据结构课程笔记">《数据结构》课程笔记</a>
<ul>
<li><a href="#算法时间复杂度">算法时间复杂度</a>
<ul>
<li><a href="#数学基础">数学基础</a></li>
<li><a href="#算法时间复杂度分析实例">算法时间复杂度分析实例</a>
<ul>
<li><a href="#例0-热身">例0: 热身</a></li>
<li><a href="#例1">例1</a></li>
<li><a href="#例2">例2</a></li>
<li><a href="#例3">例3</a></li>
<li><a href="#例4">例4</a></li>
</ul></li>
<li><a href="#递归算法的时间复杂度分析">递归算法的时间复杂度分析</a></li>
</ul></li>
<li><a href="#排序算法">排序算法</a>
<ul>
<li><a href="#两种基本排序冒泡排序与选择排序">两种基本排序：冒泡排序与选择排序</a>
<ul>
<li><a href="#冒泡排序">冒泡排序</a></li>
<li><a href="#改进的冒泡排序">改进的冒泡排序</a></li>
<li><a href="#冒泡排序运行样例">冒泡排序运行样例</a></li>
<li><a href="#选择排序">选择排序</a></li>
<li><a href="#改进的选择排序">改进的选择排序</a></li>
<li><a href="#选择排序运行样例">选择排序运行样例</a></li>
</ul></li>
<li><a href="#插入排序">插入排序</a>
<ul>
<li><a href="#算法概述">算法概述</a></li>
<li><a href="#时间复杂度分析">时间复杂度分析</a></li>
<li><a href="#插入排序运行样例">插入排序运行样例</a></li>
</ul></li>
</ul></li>
<li><a href="#线性结构链表栈与队列">线性结构（链表、栈与队列）</a>
<ul>
<li><a href="#链表">链表</a>
<ul>
<li><a href="#node节点类"><code>Node</code>节点类</a></li>
<li><a href="#链表往后递推的写法">链表往后递推的写法：</a></li>
<li><a href="#对节点的理解">对节点的理解：</a></li>
<li><a href="#链表结构及各种方法的实现">链表结构及各种方法的实现</a>
<ul>
<li><a href="#linkedlist-linkedlistt-constructor方法以及一个简单的tostring方法">LinkedList(), LinkedList(T[]) (constructor方法),以及一个简单的toString()方法</a></li>
<li><a href="#增加节点方法addaddfirstinsertint-t">增加节点方法<code>add()</code>、<code>addFirst()</code>、<code>insert(int, T)</code>：</a></li>
<li><a href="#移除节点方法的三种写法removetbooleanremoveintvoidremoveint">移除节点方法的三种写法<code>remove(T)</code>、<code>(boolean)remove(int)</code>、<code>(void)remove(int)</code></a></li>
</ul></li>
<li><a href="#完整代码">完整代码：</a></li>
</ul></li>
<li><a href="#栈">栈</a>
<ul>
<li><a href="#数组建栈">数组建栈</a>
<ul>
<li><a href="#栈结构">栈结构</a></li>
<li><a href="#类内变量以及stackstackintconstructor方法">类内变量以及<code>Stack()</code>、<code>Stack(int)</code>(constructor方法)</a></li>
<li><a href="#出栈进栈方法pushpop">出栈、进栈方法<code>push()</code>、<code>pop()</code></a></li>
<li><a href="#tostring方法">toString()方法</a></li>
<li><a href="#运行与测试结果">运行与测试结果</a></li>
</ul></li>
<li><a href="#链表建栈">链表建栈</a></li>
<li><a href="#两种建栈方式完整代码">两种建栈方式完整代码</a>
<ul>
<li><a href="#由数组建栈">由数组建栈</a></li>
<li><a href="#由链表建栈">由链表建栈</a></li>
</ul></li>
</ul></li>
<li><a href="#队列">队列</a>
<ul>
<li><a href="#通过节点创建队列">通过节点创建队列</a>
<ul>
<li><a href="#队列的遍历">队列的遍历</a></li>
<li><a href="#出队与入队操作">出队与入队操作</a></li>
<li><a href="#size与tostring方法"><code>size()</code>与<code>toString()</code>方法</a></li>
<li><a href="#运行及输出结果">运行及输出结果</a></li>
</ul></li>
<li><a href="#通过链表创建队列">通过链表创建队列</a></li>
<li><a href="#通过两个栈stack创建队列">通过两个栈(Stack)创建队列</a>
<ul>
<li><a href="#stack">Stack()</a></li>
<li><a href="#enqueuedeqeueu入队列出队列方法"><code>enQueue()</code>、<code>deQeueu()</code>入队列、出队列方法</a></li>
<li><a href="#sizetostring方法"><code>size()</code>、<code>toString()</code>方法</a></li>
</ul></li>
<li><a href="#三种创建方法完整代码">三种创建方法完整代码</a>
<ul>
<li><a href="#通过节点创建">通过节点创建</a></li>
<li><a href="#通过链表创建">通过链表创建</a></li>
<li><a href="#通过两个栈创建">通过两个栈创建</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#非线性结构树图">非线性结构（树、图）</a>
<ul>
<li><a href="#树">树</a>
<ul>
<li><a href="#定义">定义</a></li>
<li><a href="#树的性质">树的性质</a>
<ul>
<li><a href="#节点与路径">节点与路径</a></li>
<li><a href="#高度与深度">高度与深度</a></li>
<li><a href="#二叉树的定义">二叉树的定义</a></li>
<li><a href="#二叉树的性质">二叉树的性质</a></li>
<li><a href="#满二叉树与完全二叉树">满二叉树与完全二叉树</a></li>
</ul></li>
<li><a href="#树的构建">树的构建</a>
<ul>
<li><a href="#数组表示法">数组表示法</a></li>
<li><a href="#节点表示法">节点表示法</a>
<ul>
<li><a href="#树节点treenode类">树节点<code>TreeNode</code>类</a></li>
<li><a href="#树的遍历递归方法">树的遍历（递归方法）</a></li>
<li><a href="#树的遍历以栈为辅助结构">树的遍历（以栈为辅助结构）</a></li>
<li><a href="#构建一棵树以前序构建为例">构建一棵树（以前序构建为例）</a></li>
<li><a href="#最后的constructor">最后的<code>constructor</code></a></li>
</ul></li>
</ul></li>
<li><a href="#测试树的构建">测试树的构建</a></li>
<li><a href="#树类以及树节点类完整代码">树类（以及树节点类）完整代码</a></li>
</ul></li>
<li><a href="#二叉搜索树binary-search-tree">二叉搜索树(Binary Search Tree)</a>
<ul>
<li><a href="#实用小技巧">实用小技巧</a></li>
<li><a href="#二叉搜索树方法查找插入和删除">二叉搜索树方法（查找、插入和删除）</a>
<ul>
<li><a href="#查找boolean-searcht-ele">查找<code>boolean search(T ele)</code></a></li>
<li><a href="#插入boolean-insertt-ele">插入<code>boolean insert(T ele)</code></a></li>
<li><a href="#删除deletet-ele">删除<code>delete(T ele)</code></a></li>
</ul></li>
<li><a href="#二叉搜索树运行实例">二叉搜索树运行实例</a></li>
<li><a href="#二叉搜索树bst完整代码">二叉搜索树(BST)完整代码</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<!-- /TOC -->
<h2 id="算法时间复杂度">算法时间复杂度</h2>
<h3 id="数学基础">数学基础</h3>
<blockquote>
<p>[定义 1] 大<span class="math inline">\(O\)</span>标号： 若存在正常数<span class="math inline">\(c\)</span>和<span class="math inline">\(n_0\)</span>，使得在<span class="math inline">\(N \geq n_0\)</span>时，有<span class="math inline">\(T(N) \leq cf(N)\)</span>，则记为<span class="math inline">\(T(N) = O(f(N))\)</span></p>
<p>[定义 2] 大<span class="math inline">\(\Omega\)</span>标号： 若存在正常数<span class="math inline">\(c\)</span>和<span class="math inline">\(n_0\)</span>，使得在<span class="math inline">\(N \geq n_0\)</span>时，有<span class="math inline">\(T(N) \geq cg(N)\)</span>，则记为<span class="math inline">\(T(N) = \Omega (g(N))\)</span></p>
<p>[定义 3] 大<span class="math inline">\(\Theta\)</span>标号： <span class="math inline">\(T(N) = \Theta (h(N))\)</span>当且仅当 <span class="math inline">\(T(N) = O(h(N))\)</span> 且 <span class="math inline">\(T(N) = \Omega(h(N))\)</span></p>
<p>[定义 4] 小<span class="math inline">\(o\)</span>标记： 若对任意的正常数<span class="math inline">\(c\)</span>都存在<span class="math inline">\(n_0\)</span>,使得当<span class="math inline">\(N &gt; n_0\)</span>时<span class="math inline">\(T(N) &lt; cp(N)\)</span>，则<span class="math inline">\(T(N) = o(p(N))\)</span></p>
</blockquote>
<p>理解：大<span class="math inline">\(O\)</span>标号表示算法时间复杂度的上限，即若<span class="math inline">\(T(N) = O(f(N))\)</span>，<span class="math inline">\(T(N)\)</span>的时间复杂度小于等于<span class="math inline">\(f(N)\)</span>的复杂度；而小<span class="math inline">\(o\)</span>标号则意味着<span class="math inline">\(T(N)\)</span>的时间复杂度小于<span class="math inline">\(f(N)\)</span>，即<span class="math inline">\(T(N) = o(f(N)) \iff T(N) = O(f(N)) \ and \ T(N) \neq \Theta(N)\)</span>。<br />
大<span class="math inline">\(\Omega\)</span>标号表示算法时间复杂度的下限；大<span class="math inline">\(\Theta\)</span>标号表示两个时间复杂度同级别</p>
<p>算法分为<code>best-case</code>、<code>average-case</code>以及<code>worse-case</code>三种情况。 &gt; Worst-case analysis is easier to perform, so the analysis is generally conducted for the worst case.</p>
<p>对最坏情况的分析易于实现，故算法分析大体上面向<code>worse-case</code>。因此，大<span class="math inline">\(O\)</span>记号最多被采用。关于大<span class="math inline">\(O\)</span>记号的一些运算性质如下：<br />
&gt; 法则1： 如果<span class="math inline">\(T_1(N) = O(f(N))\)</span>且<span class="math inline">\(T_2(N) = O(g(N))\)</span>，那么有<br />
&gt; (a). <span class="math inline">\(T_1(N) + T_2(N) = O(f(N) + g(N)) ( = max{O(f(N)), O(g(N))}\)</span><br />
&gt; (b). <span class="math inline">\(T_1(N) * T_2(N) = O(f(N) * g(N))\)</span></p>
<blockquote>
<p>法则2：如果<span class="math inline">\(T(N)\)</span>是一个<span class="math inline">\(k\)</span>次多项式，那么<span class="math inline">\(T(N) = \Theta (N^k)\)</span></p>
</blockquote>
<blockquote>
<p>法则3: 对于任意常数<span class="math inline">\(k\)</span>，<span class="math inline">\(log^kN = O(N)\)</span>，这告诉我们对数增长得非常缓慢</p>
</blockquote>
<p>对于法则3，做一个简短的证明。（可能不严密）考虑式子 <span class="math display">\[log^kN \leq cN\]</span> 两边取对数 <span class="math display">\[ log(klogN) = log(log^kN) \leq log(cN) = logN + logc\]</span> 令 <span class="math inline">\(t = logN\)</span>，得到 <span class="math display">\[ log(kt) \leq t + logc \Longrightarrow logt \leq t + C \ (C为常数)\]</span> 而<span class="math inline">\(logt = O(t)\)</span>，故此式成立。可推得<span class="math inline">\(log^kN = O(N)\)</span>。这告诉我们<span class="math inline">\(N\)</span>是<span class="math inline">\(log^kN\)</span>的同阶或更小阶。<br />
为了简便起见，我们约定忽略大<span class="math inline">\(O\)</span>记号里的低阶项。如<span class="math inline">\(O(N^2 + N + c)\)</span>应写成<span class="math inline">\(O(N^2)\)</span></p>
<hr />
<p>注意：<span class="math inline">\(T(n) = O(f(n))\)</span>代表着当<span class="math inline">\(n\)</span>趋向于<span class="math inline">\(\inf\)</span>时，该算法的时间复杂度<span class="math inline">\(T(n)\)</span>为<span class="math inline">\(f(n)\)</span>的等阶或低阶无穷大量。例如<span class="math inline">\(T(n) = n\)</span>既可以说是<span class="math inline">\(O(n)\)</span>阶的，也可以说是<span class="math inline">\(O(n^2)\)</span>阶的；但更精确的写法是<span class="math inline">\(O(n)\)</span>阶。<br />
而即使两个算法时间复杂度是同阶的，也不意味着它们的运行效率相等。这是因为两个同阶算法的复杂度并非一定相同，而是成一个倍数<span class="math inline">\(k(k \in \\R)\)</span>的，且我们在计算时忽略了低阶项。</p>
<hr />
<h3 id="算法时间复杂度分析实例">算法时间复杂度分析实例</h3>
<p>算法的阶数大致有：<span class="math inline">\(O(1), O(logn), O(n^2), O(n^3), O(2^n)\)</span>，分别代表常数阶，对数阶，平方阶，立方阶，指数阶。<br />
大<span class="math inline">\(O\)</span>标号只是对算法时间复杂度的阶级进行了测度，而一个重要的指标是算法时间复杂度<span class="math inline">\(T(n)\)</span>随规模<span class="math inline">\(n\)</span>的增长速度。它通过算法对应阶数的导数可以大致得出。<br />
不同阶算法的时间复杂度随算法规模变化的规律，如下图所示。 <img src="../medias/images/notes/p10.png" /></p>
<h4 id="例0-热身">例0: 热身</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    k = k + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设语句<code>k = k + 5</code>的执行时间为常数<span class="math inline">\(c\)</span>，而该语句被运行了<span class="math inline">\(n\)</span>次，故算法的时间复杂度<span class="math inline">\(T(n) = c * n = O(n)\)</span></p>
<h4 id="例1">例1</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; j++) &#123;</span><br><span class="line">        k = k + i + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设语句<code>k = k + i + j</code>的运行时间为<span class="math inline">\(c\)</span>，在内循环中该语句被执行了20次，而内循环一共被执行了<span class="math inline">\(n\)</span>次，故算法时间复杂度<span class="math inline">\(T(n) = n * 20 * c = O(n)\)</span><br />
实际上，在熟练后，可省略设算法运行时间为<span class="math inline">\(c\)</span>的过程，而直接用语句的执行次数代表<span class="math inline">\(T(n)\)</span>。</p>
<h4 id="例2">例2</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">        k = k + i + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内循环被执行了<span class="math inline">\(i\)</span>次，而<span class="math inline">\(i\)</span>从<span class="math inline">\(1\)</span>变化到<span class="math inline">\(n\)</span>。每一次循环，语句被执行的次数是不一样的；因此，需要把每次执行次数相加。选择排序的时间复杂度就与之类似。 <span class="math display">\[T(n) = 1 + 2 + \cdots + n = \frac{n(n+1)}{2} = O(n^2)\]</span></p>
<h4 id="例3">例3</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (list.contains(e)) &#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">for</span> (Object t: list) &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>求解这道题需要回到大<span class="math inline">\(O\)</span>标记的定义上： &gt; 大<span class="math inline">\(O\)</span>标号： 若存在正常数<span class="math inline">\(c\)</span>和<span class="math inline">\(n_0\)</span>，使得在<span class="math inline">\(N \geq n_0\)</span>时，有<span class="math inline">\(T(N) \leq cf(N)\)</span>，则记为<span class="math inline">\(T(N) = O(f(N))\)</span></p>
<p>大<span class="math inline">\(O\)</span>标号表示的是算法的渐进上界，即算法最坏情况下的时间复杂度。因此需要考虑算法运行的最坏情况。</p>
$
<span class="math display">\[\begin{aligned}
T(n) &amp;= if语句选择时间 + max(true情况运行时间, false情况运行时间)  \\
  &amp; =  O(n) + max(O(1), O(n)) \\ 
  &amp; = O(n)
\end{aligned}\]</span>
<p>$</p>
<h4 id="例4">例4</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i *= <span class="number">2</span>) &#123;</span><br><span class="line">    Sysetm.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设<code>for</code>循环中的语句被执行了<span class="math inline">\(k\)</span>次，有 <span class="math display">\[2^k \leq n \Longrightarrow k \leq log_2n \]</span> 故<span class="math inline">\(T(n) = log_2n = logn\)</span>。</p>
<h3 id="递归算法的时间复杂度分析">递归算法的时间复杂度分析</h3>
<p>常见递归函数及其时间复杂度表如下： <img src="../medias/images/notes/p11.png" /> 给出一些简单的证明（可能不严谨）： - <span class="math inline">\(T(n) = T(n / 2) + O(1)\)</span><br />
【证明】：<span class="math inline">\(T(n) = T(n / 2) + 1 = T(n / 4) + 2 = \cdots = T(n / 2^k) + k\)</span><br />
存在一个足够大的<span class="math inline">\(k\)</span>，满足 <span class="math inline">\(n / 2^k \leq 1 \Longrightarrow k \geq log_2n\)</span>，即<span class="math inline">\(T(n / 2^k) = T(1) = 1\)</span><br />
故<span class="math inline">\(T(n) = k + 1 = O(logn)\)</span></p>
<ul>
<li><p><span class="math inline">\(T(n) = T(n - 1) + O(1)\)</span><br />
【证明】：易证<span class="math inline">\(T(n) = T(n-1) + 1 = \cdots = T(1) + n-1 = n = O(n)\)</span></p></li>
<li><p><span class="math inline">\(T(n) = 2T(n / 2) + O(1)\)</span><br />
【证明】：<br />
$</p>
<span class="math display">\[\begin{aligned}
T(n) &amp; = 2T(n / 2) + 1 = 2^2 T(n / 4) + (2^0 + 2^1) \\
  &amp; = \cdots \\
  &amp; = 2^k T(n / 2^k) + (2^0 + 2^1 + \cdots + 2^{k - 1})
\end{aligned}\]</span>
<p>$<br />
同样，存在一个足够大的<span class="math inline">\(k\)</span>，满足 <span class="math inline">\(n / 2^k \leq 1 \Longrightarrow k \geq log_2n\)</span>，即<span class="math inline">\(T(n / 2^k) = T(1) = 1\)</span><br />
<span class="math inline">\(T(n) = 2^k + (2^0 + 2^1 + \cdots + 2^{k-1}) = 2^{k+1} - 1 = O(n)\)</span></p></li>
<li><p><span class="math inline">\(T(n) = 2T(n / 2) + O(n)\)</span><br />
【证明】:<br />
$</p>
<span class="math display">\[\begin{aligned}
T(n) &amp; = 2T(n/2) + n \\
  &amp; = 2(2T(n/4) + \frac{n}{2}) + n = 2^2T(n/4) + 2n \\
  &amp; = \cdots \\ 
  &amp; = 2^kT(n/2^k) + kn \\
  &amp; = O(n) + O(nlogn) = O(nlogn)
\end{aligned}\]</span>
<p>$<br />
注意：<span class="math inline">\(T(n) = 2T(n / 2) + n\)</span>,那么<span class="math inline">\(T(n/2) = 2T(n / 4) + n / 2\)</span>。这里的<span class="math inline">\(n\)</span>需要相应替换成<span class="math inline">\(n/2\)</span></p></li>
<li><p><span class="math inline">\(T(n) = T(n - 1) + O(n)\)</span><br />
【证明】：<span class="math inline">\(T(n) = T(n-1) + n = T(n-2) + n-1 + n = \cdots = 1 + 2 + \cdots + n = \frac{n(n+1)}{2}\)</span></p></li>
<li><p><span class="math inline">\(T(n) = 2T(n - 1) + O(1)\)</span><br />
【证明】：<br />
$</p>
<span class="math display">\[\begin{aligned}
T(n) &amp; = 2T(n - 1) + 1 \\
  &amp; = 2(2T(n - 2) + 1) + 1 = 2^2 T(n - 2) + (2^0 + 2^1) \\
  &amp; = \cdots \\ 
  &amp; = 2^{n-1} T(1) + (2^0 + 2^1 + \cdots + 2^{n - 2}) \\
  &amp; = 2^0 + 2^1 + \cdots + 2^{n-1} = 2^n - 1 = O(2^n)
\end{aligned}\]</span>
<p>$</p></li>
<li><p><span class="math inline">\(T(n) = T(n - 1) + T(n - 2) + O(1)\)</span> 【证明】（采用了放缩的方法）：<br />
$</p>
<span class="math display">\[\begin{aligned}
T(n) &amp; = T(n - 1) + T(n - 2) + 1 \\ 
  &amp; \leq 2T(n - 1) + 1 \leq 2(2T(n - 2) + 1) + 1 \\
  &amp; \leq 2^2T(n - 2) + (2^0 + 2^1) \\
  &amp; \cdots \\ 
  &amp; \leq 2^{n - 1}T(1) + (2^0 + 2^1 + \cdots + 2^{n - 2}) \\
  &amp; = 2^0 + 2^1 + \cdots + 2^{n - 1} = 2^n - 1 = O(2^n)
\end{aligned}\]</span>
<p>$</p></li>
</ul>
<h2 id="排序算法">排序算法</h2>
<h3 id="两种基本排序冒泡排序与选择排序">两种基本排序：冒泡排序与选择排序</h3>
<h4 id="冒泡排序">冒泡排序</h4>
<p>基本思想：遍历数组并进行相邻元素的交换，使得每个局部位置上，数组都是从小到大排列；这样一趟下来，一个最大元素会移到最右边。若数组长度为<span class="math inline">\(n\)</span>，则只需执行<span class="math inline">\(n - 1\)</span>趟即可。<br />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(Comparable[] array)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// i表示执行的次数； 只需执行array.length - 1次，出循环时数组已然有序</span></span><br><span class="line">       <span class="comment">// 因为每次把一个最大的放到后面，执行array.length - 1次时，在最前边还剩下的一个元素一定是最小的</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++)</span><br><span class="line">		<span class="comment">// 因为是每个元素和它后面的比较，所以只要遍历到数组尾元素前一个就行了</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++)</span><br><span class="line">			<span class="comment">// 把第i大的元素放到数组的倒数第array.length-i个位置</span></span><br><span class="line">			<span class="keyword">if</span> (array[j].compareTo(array[j + <span class="number">1</span>]) &gt; <span class="number">0</span>)</span><br><span class="line">				swap(array, j, j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 注意：在最优的算法中，遍历趟数只要<span class="math inline">\(n - 1\)</span>趟（设数组长度为<span class="math inline">\(n\)</span>）；而每趟中要将第<span class="math inline">\(j\)</span>个元素与它后面元素比较，<span class="math inline">\(j\)</span>的取值从<span class="math inline">\(0\)</span>到<span class="math inline">\(n - 2\)</span>。<br />
算法时间复杂度分析： <span class="math display">\[T(n) = n-1 + n-2 + \cdots + 1 = \frac{n(n-1)}{2} = O(n^2)\]</span></p>
<h4 id="改进的冒泡排序">改进的冒泡排序</h4>
<p>实际上，在数组基本有序的情况下，不需要执行<span class="math inline">\(n - 1\)</span>趟遍历。<br />
考虑第<span class="math inline">\(i(i \in \{0, 1, \cdots, n - 2\})\)</span>趟遍历的情形：此时数组中第<span class="math inline">\(n - i - 1\)</span>位置以后均已有序，该趟遍历的目标是使第<span class="math inline">\(i + 1\)</span>大的数到第<span class="math inline">\(n - i - 1\)</span>位置上去。<br />
若该趟遍历中，没有发生元素的交换，也就是说，数组中<span class="math inline">\([0, n - i - 1]\)</span>位置是有序的，那么根据上面的结论，整个数组有序。<br />
此时，排序无需继续进行。根据此思想，写出改进的冒泡排序算法：<br />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">improvedBubbleSort</span><span class="params">(Comparable[] array)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// i表示执行的次数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="comment">// flag表示是否有交换</span></span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">		<span class="comment">// 因为是每个元素和它后面的比较，所以只要遍历到数组尾元素前一个就行了</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++)</span><br><span class="line">			<span class="comment">// 把最大的放到数组后面</span></span><br><span class="line">			<span class="keyword">if</span> (array[j].compareTo(array[j + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				swap(array, j, j + <span class="number">1</span>);</span><br><span class="line">				<span class="comment">// 有交换，flag为true</span></span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">// 若一趟遍历无交换，停止排序算法</span></span><br><span class="line">		<span class="keyword">if</span> (!flag) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 因此，可以看出，在数组基本有序的情况下，采用冒泡排序比较适合。</p>
<h4 id="冒泡排序运行样例">冒泡排序运行样例</h4>
<p>应用冒泡排序对以下数组进行排序<br />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparable[] a = &#123;<span class="number">9</span> ,<span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure> 每次排序后，数组情况如下： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[OUTPUT]:</span><br><span class="line"><span class="number">9</span> <span class="number">5</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">9</span> </span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">9</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">9</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">9</span> </span><br></pre></td></tr></table></figure> 改进后的冒泡排序： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[OUTPUT]: </span><br><span class="line"><span class="number">9</span> <span class="number">5</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">9</span> </span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">9</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">9</span> </span><br></pre></td></tr></table></figure> 可以看出，改进后的冒泡排序比原先少了一次遍历。因此算法时间复杂度降低。</p>
<h4 id="选择排序">选择排序</h4>
<p>基本思想：在第<span class="math inline">\(i(i \in \{0, 1, \cdots, n - 2\})\)</span>趟对数组的遍历中，通过比较找出第<span class="math inline">\(i\)</span>个及以后位置中最小的元素，把它与数组的第<span class="math inline">\(i\)</span>个位置互换。共遍历<span class="math inline">\(n - 1\)</span>趟后，数组有序。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(Comparable[] array)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 预先建立内存，降低算法空间复杂度</span></span><br><span class="line">	<span class="keyword">int</span> minIndex;</span><br><span class="line">	Comparable min;</span><br><span class="line">	<span class="comment">// i代表每次处理的位置，经过一轮排序后，该位置及其以前位置都是有序的</span></span><br><span class="line">	<span class="comment">// i从0位置到数组倒数第2个位置，出循环时最后一个位置已然有序</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="comment">// 从位置i以后选取一个最小的元素与i位置元素互换</span></span><br><span class="line">		minIndex = i;</span><br><span class="line">		min = array[minIndex];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; array.length; j++)</span><br><span class="line">			<span class="keyword">if</span> (array[j].compareTo(min) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				minIndex = j;</span><br><span class="line">				min = array[minIndex];</span><br><span class="line">			&#125;</span><br><span class="line">		swap(array, i, minIndex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 算法时间复杂度分析： <span class="math display">\[T(n) = n + n-1 + \cdots + 2 = \frac{(n+2)(n+1)}{2} = O(n^2)\]</span></p>
<h4 id="改进的选择排序">改进的选择排序</h4>
<p>在第<span class="math inline">\(i\)</span>趟遍历中，在<span class="math inline">\([i, n - i - 1]\)</span>（设数组元素个数为<span class="math inline">\(n\)</span>）中分别找出最大值和最小值，并将它们与<span class="math inline">\(i\)</span>、<span class="math inline">\(n - i - 1\)</span>位置互换。这样可以减少一些算法的时间复杂度。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">improvedSelectSort</span><span class="params">(Comparable[] array)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> minIndex, maxIndex;</span><br><span class="line">	Comparable min, max;</span><br><span class="line">	<span class="comment">// 经过array.length / 2次查找后，若array.length为偶数，则array前半部分、后半部分都有序；</span></span><br><span class="line">	<span class="comment">// 若array.length为奇数，则中间剩下的奇数一定比前半部分大，比后半部分小，数组也有序</span></span><br><span class="line">	<span class="comment">// 故只要进行array.length次遍历</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">		<span class="comment">// 确定最大值、最小值</span></span><br><span class="line">		minIndex = i; </span><br><span class="line">		maxIndex = i;</span><br><span class="line">		min = array[minIndex];</span><br><span class="line">		max = array[maxIndex];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; array.length - i; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (array[j].compareTo(min) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				minIndex = j;</span><br><span class="line">				min = array[minIndex];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (array[j].compareTo(max) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				maxIndex = j;</span><br><span class="line">				max = array[maxIndex];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 考虑特殊情况：最大值在最小位置，或者最小值在最大位置</span></span><br><span class="line">		swap(array, i, minIndex);</span><br><span class="line">		<span class="keyword">if</span> (i == maxIndex)</span><br><span class="line">			maxIndex = minIndex;</span><br><span class="line">		swap(array, array.length - i - <span class="number">1</span>, maxIndex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 时间复杂度分析：<br />
<span class="math display">\[ T(n)=\left\{
\begin{aligned}
n + n - 2 + \cdots + 1 = \frac{(n+1)^2}{4} = O(n^2) &amp; \ \ n \ is \ odd \\
n + n - 2 + \cdots + 2 = \frac{(n+2)n}{2} = O(n^2)&amp; \ \ n \ is \ even
\end{aligned}
\right.\\
\Longrightarrow T(n) = O(n^2)
\]</span> 看起来时间复杂度的阶数并没有变化，但实际上用时得到了缩短。<br />
具体时间减少在哪里呢？考察算法，可以发现：虽然外部<code>for</code>循环相比原始算法调用次数减少一半，但而每次循环中，由于要同时处理最大、最小值的情况，比较次数、交换次数增加了一倍。故这部分算法没有得到提升。<br />
优化之处在于：用来比较的元素数量降低了。原先情况下，在第<span class="math inline">\(i\)</span>趟遍历中，需要在<span class="math inline">\([i, n - 1]\)</span>中找出最小值；而优化后只需在<span class="math inline">\([i, n - i - 1]\)</span>数组中寻找。<br />
虽然优化的程度没有达到能够使得算法降低阶数，但却是运行时间得到了减小。这也印证了“算法时间复杂度同阶不意味着运算时间相同”的说法。</p>
<p>注意（设数组元素个数为<span class="math inline">\(n\)</span>）：<br />
- 遍历次数为<span class="math inline">\(n / 2\)</span>，原因如下： - 若<span class="math inline">\(n\)</span>为偶数，则<span class="math inline">\(n = n / 2 * 2\)</span>，经过<span class="math inline">\(n / 2\)</span>次遍历后，数组的<span class="math inline">\([0, n / 2 - 1]\)</span>元素与<span class="math inline">\([n / 2, n - 1]\)</span>元素均有序，又由于每次遍历中找到的<span class="math inline">\(min \leq max\)</span>，知数组有序。 - 若<span class="math inline">\(n\)</span>为奇数，则<span class="math inline">\(n = n / 2 * 2+ 1\)</span>，经过<span class="math inline">\(n / 2\)</span>次遍历后，数组<span class="math inline">\([0, n / 2 - 1]\)</span>位置与<span class="math inline">\([n / 2 + 1, n - 1]\)</span>元素均有序，而处于中间的为第<span class="math inline">\(n / 2\)</span>位置的元素。在最后一次遍历后，有以下关系：<span class="math inline">\(min \leq array[n / 2] \leq max\)</span>，故数组也是有序。 故只要进行<span class="math inline">\(n / 2\)</span>次遍历，即可使得数组有序。</p>
<ul>
<li>在交换最大值、最小值与最大、最小位置时，要考虑特殊情况：最大值在最小位置 / 最小值在最大位置
<ul>
<li>原因：若最大值在最小位置。先将最小值与最小位置元素互换，此时原最大值标记位置（即最小位置）里存储的值已经不是最大值而是最小值。当下面将最大值与最大位置储存的元素互换时，就会出现问题。</li>
<li>解决：先将最小值与最小位置元素互换。若最大值在最小位置，则此时最大值的标记位置应改为原最小值标记位置。之后再将最大值标记位置与最大位置互换即可。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">swap(array, i, minIndex);</span><br><span class="line"><span class="keyword">if</span> (i == maxIndex)</span><br><span class="line">	maxIndex = minIndex;</span><br><span class="line">swap(array, array.length - i - <span class="number">1</span>, maxIndex);</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="选择排序运行样例">选择排序运行样例</h4>
<p>同样选取 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparable[] a = &#123;<span class="number">9</span> ,<span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure> 作为待排序数组<br />
每次排序后，数组内容如下： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[OUTPUT]: </span><br><span class="line"><span class="number">9</span> <span class="number">5</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">9</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">9</span> <span class="number">5</span> <span class="number">3</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">9</span> <span class="number">5</span> <span class="number">4</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">9</span> </span><br></pre></td></tr></table></figure> 改进的选择排序： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[OUTPUT]: </span><br><span class="line"><span class="number">9</span> <span class="number">5</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">9</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">3</span> <span class="number">5</span> <span class="number">9</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">9</span> </span><br></pre></td></tr></table></figure></p>
<h3 id="插入排序">插入排序</h3>
<h4 id="算法概述">算法概述</h4>
<p>基本思想： 就如同洗牌一样，该算法每轮把一个元素插入到一系列排好的数组对应位置，使得数组仍旧有序。具体实现如下：<br />
将一个数组分为两部分。左半部分已排序，而右半部分未排序，右半部分的第一个位置为边界。需要完成<span class="math inline">\(n - 1\)</span>轮排序。（数组的元素个数为<span class="math inline">\(n\)</span>）。在每一轮排序中，初始指针指向边界值。将指针所指元素与它前一个元素比较。<br />
若前方元素<span class="math inline">\(&gt;\)</span>指针位置元素，则将其复制到指针位置，指针前移；若前一个元素<span class="math inline">\(\leq\)</span>指针位置元素，将边界元素插入到当前指针位置，（指针若不指向边界处，则当前指针位置原先元素已经被复制到了后一个位置，即完成了后移）随后结束这一轮遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(Comparable[] array)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	Comparable boundValue;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> bound = <span class="number">1</span>; bound &lt; array.length; bound++) &#123;</span><br><span class="line">		<span class="comment">// 存储边界处元素的值</span></span><br><span class="line">		boundValue = array[bound];</span><br><span class="line">		<span class="comment">// 在找到第1个比边界值小的元素之前，不断复制（后移）数组内元素</span></span><br><span class="line">		<span class="keyword">for</span> (temp = bound; temp &gt; <span class="number">0</span> &amp;&amp; array[temp - <span class="number">1</span>].compareTo(boundValue) &gt; <span class="number">0</span>; temp--)</span><br><span class="line">			array[temp] = array[temp - <span class="number">1</span>];</span><br><span class="line">		<span class="comment">// 插入-------</span></span><br><span class="line">		array[temp] = boundValue;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意： - 内部<code>for</code>循环终止的条件非常关键。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">temp &gt; <span class="number">0</span> &amp;&amp; array[temp - <span class="number">1</span>].compareTo(boundValue) &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure> 逻辑应理解为：首先判断<code>temp</code>是否<span class="math inline">\(&gt;0\)</span>，若否，则不再检验<code>&amp;&amp;</code>后面的条件；若是，再进行比较两元素大小。这种写法不会报错。</p>
<ul>
<li><p>需要使用一个<code>Comparable</code>类型变量<code>boundValue</code>来储存边界处元素的值。原因为：经过第一次复制（后移）后，边界处元素会改变</p></li>
<li><p>算法也可以写作每个元素与它前面元素比较的形式。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span> </span>&#123;</span><br><span class="line"><span class="comment">/** The method for sorting the numbers */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] list)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">		<span class="comment">/** Insert list[i] into a sorted sublist list[0..i-1] so that list[0..i] is sorted. */</span></span><br><span class="line">		<span class="keyword">int</span> currentElement = list[i];</span><br><span class="line">		<span class="keyword">int</span> k;</span><br><span class="line">		<span class="keyword">for</span> (k = i - <span class="number">1</span>; k &gt;= <span class="number">0</span> &amp;&amp; list[k] &gt; currentElement; k--) &#123;</span><br><span class="line">			list[k + <span class="number">1</span>] = list[k];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Insert the current element into list[k + 1]</span></span><br><span class="line">		list[k + <span class="number">1</span>] = currentElement;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h4 id="时间复杂度分析">时间复杂度分析</h4>
<p>排序算法的主要时间复杂度发生在比较上，而在一般情况下交换、其它操作的时间要远远小于比较。（完全反序的情况除外）<br />
- Worse-case:<br />
数组完全反序时，对于第<span class="math inline">\(p\)</span>次循环，其比较次数为<span class="math inline">\(p + 1\)</span>次（<span class="math inline">\(p, p - 1, \cdots, 1, 0\)</span>）。故算法时间复杂度的上界为： <span class="math display">\[T(n) = 2 + 3 + \cdots + n = O(n^2)\]</span></p>
<ul>
<li><p>Best-case:<br />
数组基本有序时对于每一趟遍历，只需进行1次比较。故算法时间复杂度的下界为：<span class="math inline">\(O(n)\)</span></p></li>
<li><p>Average-case: 通过逆序等知识，可得出该算法平均时间复杂度为<span class="math inline">\(\Theta(n^2)\)</span></p></li>
</ul>
<h4 id="插入排序运行样例">插入排序运行样例</h4>
<p>选取 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparable[] a = &#123;<span class="number">9</span> ,<span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure> 作为待排序数组<br />
每次排序后，数组内容如下： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[OUTPUT]:</span><br><span class="line"><span class="number">9</span> <span class="number">5</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="number">5</span> <span class="number">9</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">9</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">5</span> <span class="number">9</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">9</span> <span class="number">3</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">9</span> </span><br></pre></td></tr></table></figure></p>
<h2 id="线性结构链表栈与队列">线性结构（链表、栈与队列）</h2>
<p><code>Java</code>的泛型编程：在写类时用<code>&lt;T&gt; / &lt;E&gt; / &lt;V&gt; / ...</code>表示一种数据类型，在实际编程时可替换为其它具体的数据类型（如<code>Integer / Double / ...</code>）</p>
<h3 id="链表">链表</h3>
<h4 id="node节点类"><code>Node</code>节点类</h4>
<p><img src="../medias/images/notes/p2.png" /><br />
节点类内置<code>T</code>类型的<code>data</code>变量；以及循环套用地定义了一个<code>Node</code>类型的<code>next</code>变量，表示下一个节点。<br />
Constructor方法：传入<code>T</code>类型参数data, 为类内变量<code>data</code>赋值。 <code>Node</code>之间的连接方式如下图所示： <img src="../medias/images/notes/p3.png" /></p>
<h4 id="链表往后递推的写法">链表往后递推的写法：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;T&gt; temp = head;</span><br><span class="line"><span class="comment">// Method1: </span></span><br><span class="line"><span class="keyword">while</span> (temp.getNext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ... 对temp做操作， 如打印temp的值</span></span><br><span class="line">    temp = temp.getNext();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Method2: </span></span><br><span class="line"><span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ... 对temp做操作， 如打印temp的值</span></span><br><span class="line">    temp = temp.getNext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第1种写法：可以在<code>while</code>循环内访问到从<code>head</code>到尾节点前一个节点；出循环后<code>temp</code>变为尾节点。<br />
第2种写法：可以在<code>while</code>循环内访问到从<code>head</code>到尾节点；但出循环后<code>temp</code>变为<code>null</code>，无法进行下一步操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Method3: 专用于需要对父节点进行操作的方法</span></span><br><span class="line">Node&lt;T&gt; pare = <span class="keyword">null</span>;</span><br><span class="line">Node&lt;T&gt; temp = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">    pare = temp;</span><br><span class="line">    temp = temp.getNext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第3种用法：同时定义<code>pare</code>、<code>temp</code>，将父节点与当前节点同时递推。每次循环中，父节点<code>pare</code>被赋值为当前节点，而当前节点<code>temp</code>则往后推一个节点。递推过后，<code>temp</code>表示位置为<code>index</code>的节点，而<code>pare</code>为<code>temp</code>的父节点。<br />
在节点的删除、节点的插入方法中，由于需要访问当前节点父节点的信息，会用到这种递推方法。这与链表的特性有关：它容易获取一个节点后面的节点，但是难以访问它的父节点，故需要使用递推方法获得父节点。 #### 对节点的理解： 观察如下代码： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">	Node&lt;T&gt; temp = <span class="keyword">new</span> Node&lt;T&gt;(obj);</span><br><span class="line">	temp.setNext(head);</span><br><span class="line">	head = temp;</span><br><span class="line">	size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这里的<code>temp</code>、<code>head</code>只是一个名字、一个符号，与储存节点信息的位置绑定在一起。如：通过刚刚定义的<code>temp</code>，就可以访问到<code>new Node&lt;T&gt;(obj)</code>的信息，从而改变这个节点的信息，比如使用<code>temp.setNext(head);</code>语句来将<code>temp</code>节点连接在<code>head</code>头节点前面。<br />
而既然<code>temp</code>、<code>head</code>只是一个符号，它们就可以与别的节点绑定在一起。<code>head = temp;</code>语句就是将<code>head</code>节点与<code>temp</code>所绑定的这个节点绑定在一起。那么此时头节点往前移动一位，而<code>temp</code>与<code>head</code>此时指向的是同一个节点的位置。<br />
再如在下面的小例子中，<code>temp</code>所指向的节点就不断被改变为当前节点后面的节点。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (temp.getNext() != <span class="keyword">null</span>)</span><br><span class="line">    temp = temp.getNext();</span><br></pre></td></tr></table></figure></p>
<h4 id="链表结构及各种方法的实现">链表结构及各种方法的实现</h4>
<p><img src="../medias/images/notes/p1.png" /></p>
<h5 id="linkedlist-linkedlistt-constructor方法以及一个简单的tostring方法">LinkedList(), LinkedList(T[]) (constructor方法),以及一个简单的toString()方法</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将传入的T类型数组转化为链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(T[] objs)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (T obj : objs)</span><br><span class="line">		add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String res = <span class="string">&quot;[&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">	Node&lt;T&gt; temp = head;</span><br><span class="line">       <span class="comment">// 访问从头节点到尾节点前一个节点，并把它们的toString()方法整合</span></span><br><span class="line">	<span class="keyword">while</span>(temp.getNext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		res += temp.toString() + <span class="string">&quot;, &quot;</span>;</span><br><span class="line">		temp = temp.getNext();</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">// 输出结果</span></span><br><span class="line">	<span class="keyword">return</span> res.concat(temp.toString() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行试验与结果： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    Integer[] intes = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;</span><br><span class="line">    LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;Integer&gt;(intes);</span><br><span class="line">    System.out.print(<span class="string">&quot;size: &quot;</span> + list.size + <span class="string">&quot;\n&quot;</span> + list.toString() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">[OUTPUT]: size: <span class="number">12</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br></pre></td></tr></table></figure></p>
<h5 id="增加节点方法addaddfirstinsertint-t">增加节点方法<code>add()</code>、<code>addFirst()</code>、<code>insert(int, T)</code>：</h5>
<p><code>add()</code>方法，在链表的尾部插入新节点:<br />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 若队列未初始化，则将头节点实例化</span></span><br><span class="line">	<span class="keyword">if</span> (head == <span class="keyword">null</span>) head = <span class="keyword">new</span> Node&lt;T&gt;(obj);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 定位到最后一个节点（next节点为null)</span></span><br><span class="line">		Node&lt;T&gt; temp = head;</span><br><span class="line">		<span class="keyword">while</span> (temp.getNext() != <span class="keyword">null</span>)</span><br><span class="line">			temp = temp.getNext();</span><br><span class="line">           <span class="comment">// 新建以传入的T型数据为data的节点，连接到最后一个节点后面</span></span><br><span class="line">		temp.setNext(<span class="keyword">new</span> Node&lt;T&gt;(obj));	</span><br><span class="line">	&#125;</span><br><span class="line">	size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相关方法：<code>addFirst()</code>，在链表的头部插入新节点:<br />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 建立新节点</span></span><br><span class="line">	Node&lt;T&gt; temp = <span class="keyword">new</span> Node&lt;T&gt;(obj);</span><br><span class="line">	<span class="comment">// 新节点连接到头节点前面</span></span><br><span class="line">       temp.setNext(head);</span><br><span class="line">       <span class="comment">// 头节点变为新节点</span></span><br><span class="line">	head = temp;</span><br><span class="line">	size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更高级的方法：<code>insert(int index, T data)</code>，在<code>index</code>位置插入新的节点 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用该方法后, index位置前的节点不变，index位置的节点变为储存着data的节点，而index后一个节点变为原先index位置节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, T data)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (index == <span class="number">0</span>) addFirst(data);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		Node&lt;T&gt; temp = head;</span><br><span class="line">		<span class="comment">// 得到index前面的节点</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index - <span class="number">1</span>; i++)</span><br><span class="line">			temp = temp.getNext();</span><br><span class="line">		<span class="comment">// 储存index位置的节点</span></span><br><span class="line">		Node&lt;T&gt; indexNode = temp.getNext();</span><br><span class="line">		<span class="comment">// 在index节点与它前面一个节点之间插入新节点</span></span><br><span class="line">		temp.setNext(<span class="keyword">new</span> Node&lt;T&gt;(data));</span><br><span class="line">		temp.getNext().setNext(indexNode);</span><br><span class="line">	&#125;</span><br><span class="line">	size++;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行试验与结果： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    list.add(<span class="keyword">new</span> Integer(<span class="number">13</span>));</span><br><span class="line">    System.out.print(<span class="string">&quot;size: &quot;</span> + list.size + <span class="string">&quot;\n&quot;</span> + list.toString() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    list.addFirst(<span class="keyword">new</span> Integer(<span class="number">0</span>));</span><br><span class="line">    System.out.print(<span class="string">&quot;size: &quot;</span> + list.size + <span class="string">&quot;\n&quot;</span> + list.toString() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    list.insert(<span class="number">0</span>, <span class="keyword">new</span> Integer(<span class="number">100</span>));</span><br><span class="line">    System.out.print(<span class="string">&quot;size: &quot;</span> + list.size + <span class="string">&quot;\n&quot;</span> + list.toString() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">[OUTPUT]: size: <span class="number">13</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">size: <span class="number">14</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">size: <span class="number">15</span></span><br><span class="line">[<span class="number">100</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br></pre></td></tr></table></figure></p>
<h5 id="移除节点方法的三种写法removetbooleanremoveintvoidremoveint">移除节点方法的三种写法<code>remove(T)</code>、<code>(boolean)remove(int)</code>、<code>(void)remove(int)</code></h5>
<p>Type I: <code>remove(T obj)</code>根据数据值来移除节点：<br />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据data的值来删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 父节点、子节点型定位</span></span><br><span class="line">	Node&lt;T&gt; pare = <span class="keyword">null</span>;</span><br><span class="line">	Node&lt;T&gt; temp = head;</span><br><span class="line">       <span class="comment">// 直到已经遍历了整个链表 或者 找到要删除的节点</span></span><br><span class="line">	<span class="keyword">while</span>(temp != <span class="keyword">null</span> &amp;&amp; !temp.getData().equals(obj)) &#123;<span class="comment">// 往后推移</span></span><br><span class="line">		pare = temp;</span><br><span class="line">		temp = temp.getNext();</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">// 若已经遍历了整个链表都没有找到要删除的节点</span></span><br><span class="line">	<span class="keyword">if</span> (temp == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">// 否则，若要移除的节点是头节点，直接改变head的指向即可</span></span><br><span class="line">	<span class="keyword">if</span> (temp == head) head = head.getNext();</span><br><span class="line">       <span class="comment">// 若要移除的节点是尾节点，将pare后续节点设为空，即pare变为最后一个节点</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (temp.getNext() == <span class="keyword">null</span>) pare.setNext(<span class="keyword">null</span>);</span><br><span class="line">       <span class="comment">// 否则，让pare与temp的next节点相连即可</span></span><br><span class="line">	<span class="keyword">else</span> pare.setNext(temp.getNext());</span><br><span class="line">	size--;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Type II: <code>remove(int index)</code>根据位置来移除节点（<code>boolean</code>型方法）：<br />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据节点的位置来删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 若index输入超出链表大小/index小于0，移除失败</span></span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">// 移除头街点的情况</span></span><br><span class="line">	<span class="keyword">if</span> (index == <span class="number">0</span>) head = head.getNext();</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 正常移除节点方法</span></span><br><span class="line">		Node&lt;T&gt; pare = <span class="keyword">null</span>;</span><br><span class="line">		Node&lt;T&gt; temp = head;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">			pare = temp;</span><br><span class="line">			temp = temp.getNext();</span><br><span class="line">		&#125;</span><br><span class="line">		pare.setNext(temp.getNext());</span><br><span class="line">	&#125;</span><br><span class="line">	size--;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Type III: <code>remove(int index)</code>根据位置来移除节点（<code>void</code>方法）：<br />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 该方法与上一方法不同之处在于：若index值超出范围，也可正常移除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove_v2</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// index &lt;= 0，移除头节点</span></span><br><span class="line">	<span class="keyword">if</span> (index &lt;= <span class="number">0</span>) removeFirst();</span><br><span class="line">       <span class="comment">// index &gt;= size, 即超出链表长度，移除最后一个节点</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (index &gt;= size) removeLast();</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">// 否则，正常移除节点</span></span><br><span class="line">		Node&lt;T&gt; pare = <span class="keyword">null</span>;</span><br><span class="line">		Node&lt;T&gt; temp = head;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">			pare = temp;</span><br><span class="line">			temp = temp.getNext();</span><br><span class="line">		&#125;</span><br><span class="line">		pare.setNext(temp.getNext());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>removeFirst</code>方法，移除头节点：<br />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	head = head.getNext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>removeLast()</code>方法，移除尾节点： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Node&lt;T&gt; pare = <span class="keyword">null</span>;</span><br><span class="line">	Node&lt;T&gt; temp = head;</span><br><span class="line">	<span class="keyword">while</span> (temp.getNext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		pare = temp;</span><br><span class="line">		temp = temp.getNext();</span><br><span class="line">	&#125;</span><br><span class="line">	pare.setNext(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行试验与结果： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    list.remove(<span class="keyword">new</span> Integer(<span class="number">1</span>));</span><br><span class="line">    System.out.print(<span class="string">&quot;size: &quot;</span> + list.size + <span class="string">&quot;\n&quot;</span> + list.toString() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    list.remove(<span class="number">11</span>);</span><br><span class="line">    System.out.print(<span class="string">&quot;size: &quot;</span> + list.size + <span class="string">&quot;\n&quot;</span> + list.toString() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    list.remove_v2(<span class="number">10</span>);</span><br><span class="line">    System.out.print(<span class="string">&quot;size: &quot;</span> + list.size + <span class="string">&quot;\n&quot;</span> + list.toString() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">[OUTPUT]: size: <span class="number">14</span></span><br><span class="line">[<span class="number">100</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">size: <span class="number">13</span></span><br><span class="line">[<span class="number">100</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">size: <span class="number">13</span></span><br><span class="line">[<span class="number">100</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br></pre></td></tr></table></figure></p>
<h4 id="完整代码">完整代码：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> T data;</span><br><span class="line">	<span class="keyword">private</span> Node&lt;T&gt; next;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data = data;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data = data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Node&lt;T&gt; <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Node&lt;T&gt; next)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.next = next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> data.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> Node&lt;T&gt; head;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">int</span> size = <span class="number">0</span>; </span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将传入的T类型数组转化为链表</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(T[] objs)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (T obj : objs)</span><br><span class="line">			add(obj);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (head == <span class="keyword">null</span>) head = <span class="keyword">new</span> Node&lt;T&gt;(obj);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 定位到最后一个节点（next节点为null)</span></span><br><span class="line">			Node&lt;T&gt; temp = head;</span><br><span class="line">			<span class="keyword">while</span> (temp.getNext() != <span class="keyword">null</span>)</span><br><span class="line">				temp = temp.getNext();</span><br><span class="line">			temp.setNext(<span class="keyword">new</span> Node&lt;T&gt;(obj));	</span><br><span class="line">		&#125;</span><br><span class="line">		size++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">		Node&lt;T&gt; temp = <span class="keyword">new</span> Node&lt;T&gt;(obj);</span><br><span class="line">		temp.setNext(head);</span><br><span class="line">		head = temp;</span><br><span class="line">		size++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String res = <span class="string">&quot;[&quot;</span>;</span><br><span class="line">		<span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">		Node&lt;T&gt; temp = head;</span><br><span class="line">		<span class="keyword">while</span>(temp.getNext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			res += temp.toString() + <span class="string">&quot;, &quot;</span>;</span><br><span class="line">			temp = temp.getNext();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res.concat(temp.toString() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 根据data的值来删除节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">		Node&lt;T&gt; pare = <span class="keyword">null</span>;</span><br><span class="line">		Node&lt;T&gt; temp = head;</span><br><span class="line">		<span class="keyword">while</span>(temp != <span class="keyword">null</span> &amp;&amp; !temp.getData().equals(obj)) &#123;</span><br><span class="line">			pare = temp;</span><br><span class="line">			temp = temp.getNext();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (temp == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (temp == head) head = head.getNext();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (temp.getNext() == <span class="keyword">null</span>) pare.setNext(<span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">else</span> pare.setNext(temp.getNext());</span><br><span class="line">		size--;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 根据节点的位置来删除节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (index == <span class="number">0</span>) head = head.getNext();</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			Node&lt;T&gt; pare = <span class="keyword">null</span>;</span><br><span class="line">			Node&lt;T&gt; temp = head;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">				pare = temp;</span><br><span class="line">				temp = temp.getNext();</span><br><span class="line">			&#125;</span><br><span class="line">			pare.setNext(temp.getNext());</span><br><span class="line">		&#125;</span><br><span class="line">		size--;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove_v2</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (index &lt;= <span class="number">0</span>) removeFirst();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (index &gt;= size) removeLast();</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			Node&lt;T&gt; pare = <span class="keyword">null</span>;</span><br><span class="line">			Node&lt;T&gt; temp = head;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">				pare = temp;</span><br><span class="line">				temp = temp.getNext();</span><br><span class="line">			&#125;</span><br><span class="line">			pare.setNext(temp.getNext());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		head = head.getNext();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Node&lt;T&gt; pare = <span class="keyword">null</span>;</span><br><span class="line">		Node&lt;T&gt; temp = head;</span><br><span class="line">		<span class="keyword">while</span> (temp.getNext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			pare = temp;</span><br><span class="line">			temp = temp.getNext();</span><br><span class="line">		&#125;</span><br><span class="line">		pare.setNext(<span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> size;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 使用该方法后, index位置前的节点不变，index位置的节点变为储存着data的节点，而index后一个节点变为原先index位置节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, T data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (index == <span class="number">0</span>) addFirst(data);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			Node&lt;T&gt; temp = head;</span><br><span class="line">			<span class="comment">// 得到index前面的节点</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index - <span class="number">1</span>; i++)</span><br><span class="line">				temp = temp.getNext();</span><br><span class="line">			<span class="comment">// 储存index位置的节点</span></span><br><span class="line">			Node&lt;T&gt; indexNode = temp.getNext();</span><br><span class="line">			<span class="comment">// 在index节点与它前面一个节点之间插入新节点</span></span><br><span class="line">			temp.setNext(<span class="keyword">new</span> Node&lt;T&gt;(data));</span><br><span class="line">			temp.getNext().setNext(indexNode);</span><br><span class="line">		&#125;</span><br><span class="line">		size++;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Integer[] intes = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;</span><br><span class="line">		LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;Integer&gt;(intes);</span><br><span class="line">		System.out.print(<span class="string">&quot;size: &quot;</span> + list.size + <span class="string">&quot;\n&quot;</span> + list.toString() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		list.add(<span class="keyword">new</span> Integer(<span class="number">13</span>));</span><br><span class="line">		System.out.print(<span class="string">&quot;size: &quot;</span> + list.size + <span class="string">&quot;\n&quot;</span> + list.toString() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		list.addFirst(<span class="keyword">new</span> Integer(<span class="number">0</span>));</span><br><span class="line">		System.out.print(<span class="string">&quot;size: &quot;</span> + list.size + <span class="string">&quot;\n&quot;</span> + list.toString() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		list.insert(<span class="number">13</span>, <span class="keyword">new</span> Integer(<span class="number">100</span>));</span><br><span class="line">		System.out.print(<span class="string">&quot;size: &quot;</span> + list.size + <span class="string">&quot;\n&quot;</span> + list.toString() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		list.remove(<span class="keyword">new</span> Integer(<span class="number">1</span>));</span><br><span class="line">		System.out.print(<span class="string">&quot;size: &quot;</span> + list.size + <span class="string">&quot;\n&quot;</span> + list.toString() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		list.remove(<span class="number">11</span>);</span><br><span class="line">		System.out.print(<span class="string">&quot;size: &quot;</span> + list.size + <span class="string">&quot;\n&quot;</span> + list.toString() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		list.remove_v2(<span class="number">10</span>);</span><br><span class="line">		System.out.print(<span class="string">&quot;size: &quot;</span> + list.size + <span class="string">&quot;\n&quot;</span> + list.toString() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line">size: <span class="number">12</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br><span class="line">size: <span class="number">13</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">size: <span class="number">14</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">size: <span class="number">15</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">100</span>]</span><br><span class="line">size: <span class="number">14</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">100</span>]</span><br><span class="line">size: <span class="number">13</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">100</span>]</span><br><span class="line">size: <span class="number">13</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure>
<h3 id="栈">栈</h3>
<blockquote>
<p>A stack is a Last-In-First-Out (LIFO) list, that is, an ordered list in which insertions and deletions are made at the top only.</p>
</blockquote>
<p>栈是一种后进先出（也叫先进后出）类型的列表，即一种插入和删除操作都只在<code>top</code>位置进行的有序列表。</p>
<p>栈的构建方式有：数组建栈，链表建栈，... #### 数组建栈 <img src="../medias/images/notes/p4.png" /><br />
<code>top</code>指向栈顶元素上面一个元素。实际与栈中的元素个数在数值上相同。<br />
当<code>top = 0</code>时，栈中元素个数为0，栈空。此时每放入一个元素，<code>top</code>的值往上增加1，直到<code>top = size</code>，此时栈满。<br />
栈空时出栈、栈满时入栈都是不被允许的，分别会造成<code>stackUnderFlow</code>、<code>stackOverFlow</code>错误。</p>
<table style="width:8%;">
<colgroup>
<col style="width: 8%" />
</colgroup>
<tbody>
<tr class="odd">
<td>Q: 如何使元素出栈？ A: 只要将<code>top</code>减去1即可，此时虽然数组里仍存储着需要出栈的数据，但不会被访问到，等效于数据出栈。</td>
</tr>
<tr class="even">
<td>Q: 如何使元素入栈？ A: 首先将<code>top</code>加1，然后修改当前数组内<code>top</code>位置数据为传入数据即可。</td>
</tr>
</tbody>
</table>
<h5 id="栈结构">栈结构</h5>
<p><img src="../medias/images/notes/p5.png" /><br />
##### 类内变量以及<code>Stack()</code>、<code>Stack(int)</code>(constructor方法)<br />
<code>top</code>为栈顶指针，数值上也等于站内元素数量，初始为0。<br />
<code>size</code>为最大栈容量，初始预设为<code>MAX_SIZE</code>大小。 <code>(T[]) objs</code>为预设的类内数组，未初始化。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = MAX_SIZE;</span><br><span class="line"><span class="keyword">private</span> T[] objs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	objs = (T[])<span class="keyword">new</span> Object[size];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.size = size;</span><br><span class="line">	objs = (T[])<span class="keyword">new</span> Object[size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> --- Q: 如何初始化<code>T</code>泛型类型数组？<br />
A: 像<code>new T[num];</code>这样的写法会报错，正确写法是<code>(T[])new Object[num];</code>，将<code>Object[]</code>数组强制转换为<code>T[]</code>数组。</p>
<hr />
<h5 id="出栈进栈方法pushpop">出栈、进栈方法<code>push()</code>、<code>pop()</code></h5>
<p><code>pop()</code>进栈方法要考虑空栈情况。若栈非空，则下移指针，返回栈顶元素。<br />
<code>push()</code>出栈方法要考虑堆栈满溢情况。若栈未满，即站内现有数据数量<code>top &lt; size</code>(<code>size</code>为栈容量)，则先修改指针位置数据为传入数据，再上移指针。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (top &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">return</span> objs[--top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">push</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (top &gt;= size) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	objs[top++] = obj;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="tostring方法">toString()方法</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本方法按照栈底 - 栈顶的顺序返回栈中元素的toString()方法的整合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String res = <span class="string">&quot;[&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	<span class="comment">// 整合从第一个到底数第二个栈中元素的toString()方法</span></span><br><span class="line">	<span class="keyword">for</span> (temp = <span class="number">0</span>; temp &lt; top - <span class="number">1</span>; temp++)</span><br><span class="line">		res += objs[temp].toString() + <span class="string">&quot;, &quot;</span>;</span><br><span class="line">	<span class="comment">// 连接上最后一个节点toStrin()方法</span></span><br><span class="line">	<span class="keyword">return</span> res + objs[temp].toString() + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="运行与测试结果">运行与测试结果</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;(<span class="number">20</span>);</span><br><span class="line">		stack.push(<span class="keyword">new</span> Integer(<span class="number">100</span>));</span><br><span class="line">		stack.push(<span class="keyword">new</span> Integer(<span class="number">200</span>));</span><br><span class="line">		System.out.println(stack.toString());</span><br><span class="line">		stack.pop();</span><br><span class="line">		System.out.println(stack.toString());</span><br><span class="line">		stack.push(<span class="keyword">new</span> Integer(<span class="number">1000</span>));</span><br><span class="line">		System.out.println(stack.toString());</span><br><span class="line">	&#125;</span><br><span class="line">[OUTPUT]: [<span class="number">100</span>, <span class="number">200</span>]</span><br><span class="line">[<span class="number">100</span>]</span><br><span class="line">[<span class="number">100</span>, <span class="number">1000</span>]</span><br></pre></td></tr></table></figure>
<h4 id="链表建栈">链表建栈</h4>
<p>链表建栈是极为简单的一种建栈方式，大多数方法（如<code>toString()</code>、<code>size()</code>等）都可直接从链表相应方法改过来。<br />
链表建栈的<code>push()</code>、<code>pop()</code>方法如下： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (stack.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">return</span> stack.removeLast();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">	stack.add(obj);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="两种建栈方式完整代码">两种建栈方式完整代码</h4>
<h5 id="由数组建栈">由数组建栈</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size = MAX_SIZE;</span><br><span class="line">	<span class="keyword">private</span> T[] objs;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		objs = (T[])<span class="keyword">new</span> Object[size];</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.size = size;</span><br><span class="line">		objs = (T[])<span class="keyword">new</span> Object[size];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> top;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (top &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">return</span> objs[--top];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">push</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (top &gt;= size) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		objs[top++] = obj;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String res = <span class="string">&quot;[&quot;</span>;</span><br><span class="line">		<span class="keyword">int</span> temp;</span><br><span class="line">		<span class="keyword">for</span> (temp = <span class="number">0</span>; temp &lt; top - <span class="number">1</span>; temp++)</span><br><span class="line">			res += objs[temp].toString() + <span class="string">&quot;, &quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> res + objs[temp].toString() + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;(<span class="number">20</span>);</span><br><span class="line">		stack.push(<span class="keyword">new</span> Integer(<span class="number">100</span>));</span><br><span class="line">		stack.push(<span class="keyword">new</span> Integer(<span class="number">200</span>));</span><br><span class="line">		System.out.println(stack.toString());</span><br><span class="line">		stack.pop();</span><br><span class="line">		System.out.println(stack.toString());</span><br><span class="line">		stack.push(<span class="keyword">new</span> Integer(<span class="number">1000</span>));</span><br><span class="line">		System.out.println(stack.toString());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="由链表建栈">由链表建栈</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackFromLinkedList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> LinkedList&lt;T&gt; stack;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">StackFromLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		stack = <span class="keyword">new</span> LinkedList&lt;T&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> stack.size();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (stack.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">return</span> stack.removeLast();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">		stack.add(obj);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> stack.toString();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		StackFromLinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> StackFromLinkedList&lt;Integer&gt;();</span><br><span class="line">		stack.push(<span class="keyword">new</span> Integer(<span class="number">100</span>));</span><br><span class="line">		stack.push(<span class="keyword">new</span> Integer(<span class="number">200</span>));</span><br><span class="line">		System.out.println(stack.toString());</span><br><span class="line">		stack.pop();</span><br><span class="line">		System.out.println(stack.toString());</span><br><span class="line">		stack.push(<span class="keyword">new</span> Integer(<span class="number">1000</span>));</span><br><span class="line">		System.out.println(stack.toString());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列">队列</h3>
<blockquote>
<p>Queue is:<br />
- A data structure for maintaining data. Data goes in the "rear" and out the "front." - Has a specific set of operations that can be performed on the data. - Referred to as a FIFO data structure because of the First-in, first-out organization. - Implemented as a class. An LinkedList is one way to store the data.</p>
</blockquote>
<p>队列为：<br />
- 一种存储数据的结构。数据从<code>rear</code>进队列，从<code>front</code>出队列。 - 对于操作数据有着一系列特殊的方式 - 是一种先进先出的数据结构 - 是一种类，可用<code>LinkedList</code>构建</p>
<p><img src="../medias/images/notes/p6.png" /></p>
<h4 id="通过节点创建队列">通过节点创建队列</h4>
<p>大致结构如下：<br />
<img src="../medias/images/notes/p7.png" /> 队列的状态： <img src="../medias/images/notes/p8.png" /> <code>front</code>、<code>rear</code>只是两个<code>Node&lt;T&gt;</code>类型的指针，它们指向的节点可以改变，从而使得整个队列发生变化。<br />
队空状态时，<code>front</code>与<code>rear</code>都为<code>null</code>;队内只有一个元素时，<code>front = rear = 该元素</code>;其它时候<code>front</code> <span class="math inline">\(\neq\)</span> <code>rear</code>，并可根据这两个指针的位置推知队列的长度。反过来，根据<code>front</code>与<code>rear</code>的关系也可推知队列的状态。</p>
<h5 id="队列的遍历">队列的遍历</h5>
<p>和先前的链表不同，队列遍历的结束标志并非访问到的节点的<code>next</code>节点为空，而是访问到的节点本身与<code>rear</code>尾节点相同。因此遍历队列的方式需要改变。<br />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;T&gt; temp = front;</span><br><span class="line"><span class="keyword">while</span> (temp != rear) &#123;</span><br><span class="line">    <span class="comment">// ... 对temp进行操作</span></span><br><span class="line">    temp = temp.getNext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... 可对为节点进行操作</span></span><br></pre></td></tr></table></figure> 以上方法可以对从<code>front</code>头节点到尾节点前面一个节点进行操作，并且出循环后，<code>temp</code>指向尾节点，如须对尾节点进行操作可在后面补上。</p>
<h5 id="出队与入队操作">出队与入队操作</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 进队方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 若队列为空，增加一个节点，此时front = rear</span></span><br><span class="line">	<span class="keyword">if</span> (front == <span class="keyword">null</span>) &#123;</span><br><span class="line">		front = <span class="keyword">new</span> Node&lt;T&gt;(obj);</span><br><span class="line">		rear = front;</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">// 否则只要rear后移即可</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		rear.setNext(<span class="keyword">new</span> Node&lt;T&gt;(obj));</span><br><span class="line">		rear = rear.getNext();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 出队方法，返回出队节点所储存的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 若队列为空，返回null</span></span><br><span class="line">	<span class="keyword">if</span> (front == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// 若队列只有一个节点，则清空队列，之后返回这个节点储存的数据</span></span><br><span class="line">	<span class="keyword">if</span> (front == rear) &#123;</span><br><span class="line">		T returnValue = front.getData();</span><br><span class="line">		front = <span class="keyword">null</span>;</span><br><span class="line">		rear = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">return</span> returnValue;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 否则，front直接后移，之后返回原front所储存的数据</span></span><br><span class="line">	T returnValue = front.getNext().getData();</span><br><span class="line">	front = front.getNext();</span><br><span class="line">	<span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="size与tostring方法"><code>size()</code>与<code>toString()</code>方法</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 这两个方法涉及到队列的递推</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (front == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 队列非空情况下，创建temp节点，开始递推</span></span><br><span class="line">		Node&lt;T&gt; temp = front;</span><br><span class="line">		<span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// temp从最初的front递推到rear停止</span></span><br><span class="line">		<span class="keyword">while</span> (temp != rear) &#123;</span><br><span class="line">            <span class="comment">// 但在循环内对temp的操作只到rear前一个节点停止</span></span><br><span class="line">			size++;</span><br><span class="line">			temp = temp.getNext();</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 因此需要加上队尾rear的长度</span></span><br><span class="line">		<span class="keyword">return</span> size + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (front == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">    <span class="comment">// 队列非空情况下，创建temp节点，开始递推</span></span><br><span class="line">    String res = <span class="string">&quot;[&quot;</span>;</span><br><span class="line">    Node&lt;T&gt; temp = front;</span><br><span class="line">    <span class="keyword">while</span> (temp != rear) &#123;</span><br><span class="line">        res += temp.toString() + <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        temp = temp.getNext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后补上rear尾节点的toString()</span></span><br><span class="line">    <span class="keyword">return</span> res + temp.toString() + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="运行及输出结果">运行及输出结果</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> Queue&lt;Integer&gt;();</span><br><span class="line">    queue.enQueue(<span class="keyword">new</span> Integer(<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;size: &quot;</span> + queue.size() + <span class="string">&quot; &quot;</span> + queue.toString());</span><br><span class="line">    queue.enQueue(<span class="keyword">new</span> Integer(<span class="number">2</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;size: &quot;</span> + queue.size() + <span class="string">&quot; &quot;</span> + queue.toString() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    queue.deQueue();</span><br><span class="line">    System.out.println(<span class="string">&quot;size: &quot;</span> + queue.size() + <span class="string">&quot; &quot;</span> + queue.toString() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    queue.deQueue();</span><br><span class="line">    System.out.println(<span class="string">&quot;size: &quot;</span> + queue.size() + <span class="string">&quot; &quot;</span> + queue.toString() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    queue.enQueue(<span class="keyword">new</span> Integer(<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;size: &quot;</span> + queue.size() + <span class="string">&quot; &quot;</span> + queue.toString() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    queue.enQueue(<span class="keyword">new</span> Integer(<span class="number">2</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;size: &quot;</span> + queue.size() + <span class="string">&quot; &quot;</span> + queue.toString() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">[OUTPUT]: size: <span class="number">1</span> [<span class="number">1</span>]</span><br><span class="line">size: <span class="number">2</span> [<span class="number">1</span>, <span class="number">2</span>] </span><br><span class="line">size: <span class="number">1</span> [<span class="number">2</span>] </span><br><span class="line">size: <span class="number">0</span> [] </span><br><span class="line">size: <span class="number">1</span> [<span class="number">1</span>] </span><br><span class="line">size: <span class="number">2</span> [<span class="number">1</span>, <span class="number">2</span>] </span><br></pre></td></tr></table></figure>
<h4 id="通过链表创建队列">通过链表创建队列</h4>
<p>创建方式极为简单，首先内置一个<code>LinkedList</code>链表。<code>deQueue</code>移除链表首个元素、<code>enQueue</code>方法移除链表尾部元素。</p>
<h4 id="通过两个栈stack创建队列">通过两个栈(Stack)创建队列</h4>
<p>结构如下： <img src="../../../medias/images/notes/p9.png" /></p>
<h5 id="stack">Stack()</h5>
<p>建立两个栈，一个为数据进入的栈<code>stackIn</code>，另一个为数据输出的栈<code>stackOut</code>。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">QueueFromStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	stackOut = <span class="keyword">new</span> Stack&lt;T&gt;();</span><br><span class="line">	stackIn = <span class="keyword">new</span> Stack&lt;T&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="enqueuedeqeueu入队列出队列方法"><code>enQueue()</code>、<code>deQeueu()</code>入队列、出队列方法</h5>
<p>入队列方法很简单，只要把元素压入<code>stackIn</code>栈内即可。<br />
由于栈是先进后出的结构，因此需要两个栈来实现先进后出效果.原先栈的储存是新加入数据在后，而把一个栈中元素全部压入另一个输出栈中后，由于栈的反向储存性，新加入的数据就到了栈底位置。此时，再让输出栈栈顶元素出栈，即可实现先进先出效果。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 入队列方法，直接压入stackIn中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">	stackIn.push(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 出队列方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 若队列为空，即两栈都为空，返回null</span></span><br><span class="line">	<span class="keyword">if</span> (stackIn.isEmpty() &amp;&amp; stackOut.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// 若stackOut为空，但stackIn不为空</span></span><br><span class="line">	<span class="keyword">if</span> (stackOut.isEmpty())</span><br><span class="line">           <span class="comment">// 将stackIn中所有元素压入stackOut中</span></span><br><span class="line">		<span class="keyword">while</span> (!stackIn.isEmpty())</span><br><span class="line">			stackOut.push(stackIn.pop());</span><br><span class="line">       <span class="comment">// 从stackOut中输出</span></span><br><span class="line">	<span class="keyword">return</span> stackOut.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="sizetostring方法"><code>size()</code>、<code>toString()</code>方法</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 队列的长度为两个栈长度的总和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> stackIn.size() + stackOut.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 栈的toString()方法是从栈底到栈顶进行打印，对于两个stack需要用不同方式进行打印</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 对于stackOut，队首元素（也是即将出队列的元素）在栈顶，因此需要使用reversed()方法将队列反转，之后打印</span></span><br><span class="line">	String res = reversed(stackOut).toString();</span><br><span class="line">       <span class="comment">// 去掉&quot;]&quot;</span></span><br><span class="line">	res = res.substring(<span class="number">0</span>, res.length() - <span class="number">1</span>);</span><br><span class="line">       <span class="comment">// 加入stackIn的toString()方法，不需要反转</span></span><br><span class="line">	String tempString = stackIn.toString();</span><br><span class="line">       <span class="comment">// 去掉&quot;[&quot;</span></span><br><span class="line">	res += tempString.substring(<span class="number">1</span>, tempString.length());</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>reverse()</code>方法如下 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 该方法实现反转一个栈的功能，即原先栈顶元素变为栈底元素，其它元素位置也要相应互换</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Stack&lt;T&gt; <span class="title">reversed</span><span class="params">(Stack&lt;T&gt; stack)</span></span>&#123;</span><br><span class="line">	Stack&lt;T&gt; temp = <span class="keyword">new</span> Stack&lt;T&gt;();</span><br><span class="line">	Stack&lt;T&gt; stackClone = (Stack&lt;T&gt;) stack.clone();</span><br><span class="line">	<span class="keyword">while</span> (!stackClone.isEmpty())</span><br><span class="line">		temp.push(stackClone.pop());</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="三种创建方法完整代码">三种创建方法完整代码</h4>
<h5 id="通过节点创建">通过节点创建</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Node&lt;T&gt; front;</span><br><span class="line">	<span class="keyword">private</span> Node&lt;T&gt; rear;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (front == <span class="keyword">null</span>) &#123;</span><br><span class="line">			front = <span class="keyword">new</span> Node&lt;T&gt;(obj);</span><br><span class="line">			rear = front;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			rear.setNext(<span class="keyword">new</span> Node&lt;T&gt;(obj));</span><br><span class="line">			rear = rear.getNext();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (front == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (front == rear) &#123;</span><br><span class="line">			T returnValue = front.getData();</span><br><span class="line">			front = <span class="keyword">null</span>;</span><br><span class="line">			rear = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">return</span> returnValue;</span><br><span class="line">		&#125;</span><br><span class="line">		T returnValue = front.getNext().getData();</span><br><span class="line">		front = front.getNext();</span><br><span class="line">		<span class="keyword">return</span> returnValue;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (front == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		Node&lt;T&gt; temp = front;</span><br><span class="line">		<span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (temp != rear) &#123;</span><br><span class="line">			size++;</span><br><span class="line">			temp = temp.getNext();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> size + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> front == <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (front == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">		String res = <span class="string">&quot;[&quot;</span>;</span><br><span class="line">		Node&lt;T&gt; temp = front;</span><br><span class="line">		<span class="keyword">while</span> (temp != rear) &#123;</span><br><span class="line">			res += temp.toString() + <span class="string">&quot;, &quot;</span>;</span><br><span class="line">			temp = temp.getNext();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res + temp.toString() + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Queue&lt;Integer&gt; queue = <span class="keyword">new</span> Queue&lt;Integer&gt;();</span><br><span class="line">		queue.enQueue(<span class="keyword">new</span> Integer(<span class="number">1</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;size: &quot;</span> + queue.size() + <span class="string">&quot; &quot;</span> + queue.toString());</span><br><span class="line">		queue.enQueue(<span class="keyword">new</span> Integer(<span class="number">2</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;size: &quot;</span> + queue.size() + <span class="string">&quot; &quot;</span> + queue.toString() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		queue.deQueue();</span><br><span class="line">		System.out.println(<span class="string">&quot;size: &quot;</span> + queue.size() + <span class="string">&quot; &quot;</span> + queue.toString() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		queue.deQueue();</span><br><span class="line">		System.out.println(<span class="string">&quot;size: &quot;</span> + queue.size() + <span class="string">&quot; &quot;</span> + queue.toString() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		queue.enQueue(<span class="keyword">new</span> Integer(<span class="number">1</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;size: &quot;</span> + queue.size() + <span class="string">&quot; &quot;</span> + queue.toString() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		queue.enQueue(<span class="keyword">new</span> Integer(<span class="number">2</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;size: &quot;</span> + queue.size() + <span class="string">&quot; &quot;</span> + queue.toString() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="通过链表创建">通过链表创建</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue2</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> LinkedList&lt;T&gt; list = <span class="keyword">new</span> LinkedList&lt;T&gt;();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">		list.add(obj);</span><br><span class="line">		size++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		size--;</span><br><span class="line">		<span class="keyword">return</span> list.remove(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> size;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(list.toString());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyQueue2&lt;Integer&gt; queue1 = <span class="keyword">new</span> MyQueue2&lt;Integer&gt;();</span><br><span class="line">		queue1.add(<span class="keyword">new</span> Integer(<span class="number">10</span>));</span><br><span class="line">		queue1.print();</span><br><span class="line">		queue1.add(<span class="keyword">new</span> Integer(<span class="number">100</span>));</span><br><span class="line">		queue1.print();</span><br><span class="line">		queue1.pop();</span><br><span class="line">		queue1.print();</span><br><span class="line">		queue1.pop();</span><br><span class="line">		queue1.print();</span><br><span class="line">		System.out.println(queue1.isEmpty());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="通过两个栈创建">通过两个栈创建</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueFromStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Stack&lt;T&gt; stackOut;</span><br><span class="line">	<span class="keyword">private</span> Stack&lt;T&gt; stackIn;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">QueueFromStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		stackOut = <span class="keyword">new</span> Stack&lt;T&gt;();</span><br><span class="line">		stackIn = <span class="keyword">new</span> Stack&lt;T&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (stackIn.isEmpty() &amp;&amp; stackOut.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (stackOut.isEmpty())</span><br><span class="line">			<span class="keyword">while</span> (!stackIn.isEmpty())</span><br><span class="line">				stackOut.push(stackIn.pop());</span><br><span class="line">		<span class="keyword">return</span> stackOut.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">		stackIn.push(obj);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> stackIn.size() + stackOut.size();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String res = reversed(stackOut).toString();</span><br><span class="line">		res = res.substring(<span class="number">0</span>, res.length() - <span class="number">1</span>);</span><br><span class="line">		String tempString = stackIn.toString();</span><br><span class="line">		res += tempString.substring(<span class="number">1</span>, tempString.length());</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Stack&lt;T&gt; <span class="title">reversed</span><span class="params">(Stack&lt;T&gt; stack)</span></span>&#123;</span><br><span class="line">		Stack&lt;T&gt; temp = <span class="keyword">new</span> Stack&lt;T&gt;();</span><br><span class="line">		Stack&lt;T&gt; stackClone = (Stack&lt;T&gt;) stack.clone();</span><br><span class="line">		<span class="keyword">while</span> (!stackClone.isEmpty())</span><br><span class="line">			temp.push(stackClone.pop());</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		QueueFromStack&lt;Integer&gt; queue = <span class="keyword">new</span> QueueFromStack&lt;Integer&gt;();</span><br><span class="line">		queue.enQueue(<span class="keyword">new</span> Integer(<span class="number">1</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;size: &quot;</span> + queue.size() + <span class="string">&quot; &quot;</span> + queue.toString());</span><br><span class="line">		queue.enQueue(<span class="keyword">new</span> Integer(<span class="number">2</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;size: &quot;</span> + queue.size() + <span class="string">&quot; &quot;</span> + queue.toString() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		queue.deQueue();</span><br><span class="line">		System.out.println(<span class="string">&quot;size: &quot;</span> + queue.size() + <span class="string">&quot; &quot;</span> + queue.toString() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		queue.deQueue();</span><br><span class="line">		System.out.println(<span class="string">&quot;size: &quot;</span> + queue.size() + <span class="string">&quot; &quot;</span> + queue.toString() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		queue.enQueue(<span class="keyword">new</span> Integer(<span class="number">1</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;size: &quot;</span> + queue.size() + <span class="string">&quot; &quot;</span> + queue.toString() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		queue.enQueue(<span class="keyword">new</span> Integer(<span class="number">2</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;size: &quot;</span> + queue.size() + <span class="string">&quot; &quot;</span> + queue.toString() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="非线性结构树图">非线性结构（树、图）</h2>
<h3 id="树">树</h3>
<h4 id="定义">定义</h4>
<blockquote>
<p>【Definition】A tree is a collection of nodes. The collection can be empty; otherwise, a tree consists of:<br />
(1) a distinguished node <span class="math inline">\(r\)</span>, called the root;<br />
(2) and zero or more nonempty (sub)trees <span class="math inline">\(T_1, \cdots, T_k\)</span>, each of whose roots are connected by a directed edge from <span class="math inline">\(r\)</span>.</p>
</blockquote>
<p>【定义】：树是一些节点的集合。若树非空，则树由： 1. 一个特殊的节点<span class="math inline">\(r\)</span>，被叫做根节点<br />
2. 以及大于等于零个非空子树<span class="math inline">\(T_1, \cdots, T_k\)</span>，它们的跟根节点与<span class="math inline">\(r\)</span>直接相连</p>
<p>对定义的图解如下所示： <img src="../medias/images/notes/p12.png" /></p>
<h4 id="树的性质">树的性质</h4>
<h5 id="节点与路径">节点与路径</h5>
<blockquote>
<p>degree of a node ::= number of subtrees of the node.<br />
degree of a tree ::= <span class="math inline">\(max\{degree(node)\}\)</span> parent ::= a node that has subtrees. children ::= the roots of the subtrees of a parent. siblings ::= children of the same parent. leaf (terminal node) ::= a node with degree 0 (no children).</p>
</blockquote>
<ul>
<li>节点的度：与节点相连的子树个数<br />
</li>
<li>树的度：各个节点度的最大值</li>
<li>父节点：有子树的节点</li>
<li>子节点：子树的根节点</li>
<li>兄弟节点：同一个父节点下的子节点</li>
<li>叶子节点（终结节点）：度为0的节点（没有子节点的节点）</li>
</ul>
<blockquote>
<p>Path from <span class="math inline">\(n_1\)</span> to <span class="math inline">\(n_k\)</span> ::= a (unique) sequence of nodes <span class="math inline">\(n_1, n_2, \cdots, n_k\)</span> such that <span class="math inline">\(n_i\)</span> is the parent of <span class="math inline">\(n_{i+1}\)</span> for <span class="math inline">\(1 \leq i &lt; k\)</span> length of path ::= number of edges on the path.</p>
</blockquote>
<ul>
<li>从<span class="math inline">\(n_1\)</span> 节点到<span class="math inline">\(n_k\)</span>节点的路径 ::= 一系列（唯一的）节点<span class="math inline">\(n_1, n_2, \cdots, n_k\)</span> 满足对于<span class="math inline">\(1 \leq i &lt; k\)</span>， <span class="math inline">\(n_i\)</span> 是 <span class="math inline">\(n_{i+1}\)</span> 的父节点。<br />
</li>
<li>路径的长度：<span class="math inline">\(Path\)</span>中边的条数</li>
</ul>
<h5 id="高度与深度">高度与深度</h5>
<blockquote>
<p>Depth of <span class="math inline">\(n_i\)</span>::= length of the unique path from the root to <span class="math inline">\(n_i\)</span>. Depth(root) = 0. Height of <span class="math inline">\(n_i\)</span> ::= length of the longest path from <span class="math inline">\(n_i\)</span> to a leaf. Height(leaf) = 0, and Height(D) = 2. Height (depth) of a tree ::= height(root) = depth(deepest leaf).</p>
</blockquote>
<ul>
<li><span class="math inline">\(n_i\)</span>节点的深度：从<span class="math inline">\(root\)</span>根节点到<span class="math inline">\(n_i\)</span>节点的路径长度。（即路径包含的边数）定义<span class="math inline">\(Depth(root) = 0\)</span></li>
<li><span class="math inline">\(n_i\)</span>节点的高度：从<span class="math inline">\(n_i\)</span>到叶子节点的最长路径长度。定义<span class="math inline">\(Height(leaf) = 0\)</span>, and <span class="math inline">\(Height(D) = 2\)</span></li>
<li>树的深度/高度 = <span class="math inline">\(Height(root)\)</span> = <span class="math inline">\(Depth(deppest \ leaf)\)</span>（即树的高度=树的深度）</li>
</ul>
<p>（也有的定义树的高度/深度为路径的节点数，即比这里的定义多1） 如果树的层数是从一开始，从上往下数的，树的高度/深度还等于树的层数，如下图所示： <img src="../medias/images/notes/p13.png" /></p>
<h5 id="二叉树的定义">二叉树的定义</h5>
<blockquote>
<p>【Definition】A binary tree is a tree in which no node can have more than two children.(left subtree, right subtree)</p>
</blockquote>
<p>二叉树是每个节点的子节点不多于两个的树（即只有左子树、右子树）</p>
<h5 id="二叉树的性质">二叉树的性质</h5>
<blockquote>
<p>Property1: The maximum number of nodes on level <span class="math inline">\(i\)</span> of a binary tree is <span class="math inline">\(2^{i-1}\)</span>, <span class="math inline">\(i\geq1\)</span>.<br />
Property2: The maximum nubmer of nodes in a binary tree of depth <span class="math inline">\(k\)</span> is <span class="math inline">\(2^{k} - 1\)</span>, <span class="math inline">\(k\geq1\)</span>.<br />
Property3: For any nonempty binary tree, <span class="math inline">\(T\)</span>, if <span class="math inline">\(n_0\)</span> is the number of leaf nodes and <span class="math inline">\(n_2\)</span> the number of nodes of degree 2, then <span class="math inline">\(n_0=n_2+1\)</span></p>
</blockquote>
<ul>
<li>性质1：在二叉树中，第<span class="math inline">\(i\)</span>层的最大节点数目是<span class="math inline">\(2^{i-1}\)</span>, <span class="math inline">\((i \geq 1)\)</span></li>
<li>性质2：在二叉树中，深度为<span class="math inline">\(k\)</span>的二叉树最大节点数目是<span class="math inline">\(2^{k} - 1\)</span>, <span class="math inline">\(k \geq 1\)</span>（从这里以后采用第二种定义法，根节点的深度为1）</li>
<li>性质3：对于任何非空二叉树<span class="math inline">\(T\)</span>，若<span class="math inline">\(n_0\)</span>、<span class="math inline">\(n_2\)</span>分别表示度为<span class="math inline">\(0\)</span>、<span class="math inline">\(2\)</span>的节点数，则有<span class="math inline">\(n_0 = n_2 + 1\)</span></li>
</ul>
<p>【证明】： - 性质1：数学归纳法：对于第一层，性质显然成立。设第<span class="math inline">\(k\)</span>层的最大节点数为<span class="math inline">\(2^{k - 1}\)</span>，则第<span class="math inline">\(k + 1\)</span>层节点数最大的情况是：第<span class="math inline">\(k\)</span>层的每一个节点都有两个子节点，即第<span class="math inline">\(k + 1\)</span>层有<span class="math inline">\(2^{k}\)</span>个节点。证毕。 - 性质2： <span class="math display">\[总最大节点数目=\sum_{i=1}^{k} 2^{i-1} = 2^k - 1\]</span> - 性质3：设该树度为1的节点数目为<span class="math inline">\(n_1\)</span>，总的树枝数为<span class="math inline">\(B\)</span>。根据关系，我们有：<br />
总树枝数 = 总结点数 - 1（只有根节点没有树枝伸出） = 每个节点的度之和 <span class="math display">\[B = (n_0 + n_1 + n_2) - 1 = 0*n_0 + 1*n_1 + 2*n_2\]</span> <span class="math display">\[ \Longrightarrow n_0 = n_2 + 1  \]</span></p>
<h5 id="满二叉树与完全二叉树">满二叉树与完全二叉树</h5>
<blockquote>
<p>A full binary tree of depth <span class="math inline">\(k\)</span> is a binary tree of depth <span class="math inline">\(k\)</span> having <span class="math inline">\(2^k - 1\)</span> nodes, <span class="math inline">\(k \geq 0\)</span>.<br />
A binary tree with <span class="math inline">\(n\)</span> nodes and depth <span class="math inline">\(k\)</span> is complete if its nodes correspond to the nodes numbered from <span class="math inline">\(1\)</span> to <span class="math inline">\(n\)</span> in the full binary tree of depth <span class="math inline">\(k\)</span>.</p>
</blockquote>
<ul>
<li>满二叉树：深度为<span class="math inline">\(k\)</span>，且总节点数目为<span class="math inline">\(2^k - 1\)</span>的二叉树称为满二叉树</li>
<li>完全二叉树：设该树的节点数为<span class="math inline">\(n\)</span>，深度为<span class="math inline">\(k\)</span>。若该树的<span class="math inline">\(n\)</span>个节点和同等深度的满二叉树一一对应，则该二叉树为完全二叉树。（另一种表述方法是：只有最后一层不是满节点的树） 如下图所示： <img src="../medias/images/notes/p14.png" /></li>
</ul>
<h4 id="树的构建">树的构建</h4>
<h5 id="数组表示法">数组表示法</h5>
<blockquote>
<p>If a complete binary tree with <span class="math inline">\(n\)</span> nodes (<span class="math inline">\(depth = [log n] + 1\)</span>) is represented sequentially, then for any node with index <span class="math inline">\(i\)</span>, <span class="math inline">\(1 \leq i \leq n\)</span>, we have:<br />
<span class="math inline">\(parent(i)\)</span> is at <span class="math inline">\(i / 2\)</span> if <span class="math inline">\(i\neq1\)</span>. If <span class="math inline">\(i=1\)</span>, <span class="math inline">\(i\)</span> is at the root and has no parent.<br />
<span class="math inline">\(leftChild(i)\)</span> is at <span class="math inline">\(2i\)</span> if <span class="math inline">\(2i\leq n\)</span>. If <span class="math inline">\(2i&gt;n\)</span>, then <span class="math inline">\(i\)</span> has no left child.<br />
<span class="math inline">\(rightChild(i)\)</span> is at <span class="math inline">\(2i+1\)</span> if <span class="math inline">\(2i + 1 \leq n\)</span>. If <span class="math inline">\(2i +1 &gt; n\)</span>, then <span class="math inline">\(i\)</span> has no right child.</p>
</blockquote>
<ul>
<li>若用数组表示一棵完全二叉树（<span class="math inline">\(n\)</span>个节点，深度为<span class="math inline">\(k = [logn] + 1\)</span>），对于任意序号为<span class="math inline">\(i\)</span>的节点（<span class="math inline">\(1 \leq i \ leq n\)</span>），有：
<ol type="1">
<li><span class="math inline">\(parent(i) = i / 2\ (i \neq 1)\)</span></li>
<li><span class="math inline">\(leftChild(i) = 2i\ (2i \leq n)\)</span></li>
<li><span class="math inline">\(rightChild(i) = 2i+1\ (2i+1 \leq n)\)</span></li>
</ol></li>
</ul>
<p>【证明】：<br />
先证iii.<span class="math inline">\(rightChild(i) = 2i+1\ (2i+1 \leq n)\)</span> 对于一棵完全二叉树，前<span class="math inline">\(m\)</span>层总共节点数为<span class="math inline">\(i_m = 2^m - 1\)</span>个，最后一个节点的序号就为<span class="math inline">\(i_m\)</span>。而前<span class="math inline">\(m + 1\)</span>层共有<span class="math inline">\(2i_m+1 = 2^{m+1} - 1\)</span>个节点，最后一个节点的序号为<span class="math inline">\(2i_m+1\)</span>。<br />
对于任意一个位于第<span class="math inline">\(m\)</span>层的节点<span class="math inline">\(i= 2^m - 1 - p\ (0\leq p &lt; 2^{m-1})\)</span>，<span class="math inline">\(2i + 1= 2^{m+1} - 2p - 1\)</span>。可以看出，当<span class="math inline">\(p = 0\)</span>时，<span class="math inline">\(2i+1\)</span>所对应的是第<span class="math inline">\(m+1\)</span>层最右边的节点；<span class="math inline">\(p\)</span>每增加<span class="math inline">\(1\)</span>，<span class="math inline">\(2i+1\)</span>所对应的节点向左移动两个，即为右二父节点的右子节点......以此类推，<span class="math inline">\(rightChild(i) = 2i+1\ (2i+1 \leq n)\)</span></p>
<p>由左右节点间的关系，易证ii.<span class="math inline">\(leftChild(i) = 2i\ (2i \leq n)\)</span></p>
<p>现在证明i.<span class="math inline">\(parent(i) = i / 2\ (i \neq 1)\)</span>。若<span class="math inline">\(i\)</span>为左节点，由ii知i成立。若<span class="math inline">\(i\)</span>为右节点，<span class="math inline">\((2*parent(i) + 1) / 2 = 2*parent(i) / 2 + 1 / 2 = parent(i)\)</span>，i式亦成立。</p>
<h5 id="节点表示法">节点表示法</h5>
<h6 id="树节点treenode类">树节点<code>TreeNode</code>类</h6>
<p>构建一颗二叉树需要拥有三个存储空间的节点来进行。三个存储空间分别指向<code>data</code>（存储数据）、<code>left</code>（指向左节点）、<code>right</code>（指向右节点）。节点的基本结构如下图所示： <img src="../medias/images/notes/p15.png" /> 通过节点来构造树的结构如下图所示： <img src="../medias/images/notes/p16.png" /> 根据以上思想，写出树节点的代码如下： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> T data;</span><br><span class="line">	<span class="keyword">private</span> TreeNode left;</span><br><span class="line">	<span class="keyword">private</span> TreeNode right;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data = data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下为getters and setters 方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data = data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> left;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(TreeNode left)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.left = left;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> right;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(TreeNode right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.right = right;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="树的遍历递归方法">树的遍历（递归方法）</h6>
<p>分别记左、右子树为<span class="math inline">\(L\)</span>、<span class="math inline">\(R\)</span>, 根节点为<span class="math inline">\(D\)</span><br />
遍历顺序：前序遍历：<span class="math inline">\(DLR\)</span>， 中序遍历：<span class="math inline">\(LDR\)</span>， 后序遍历：<span class="math inline">\(LRD\)</span></p>
<blockquote>
<p>Preorder: First visit root node, then preorder visit left subtree, finally preorder visit right subtree.</p>
</blockquote>
<p>前序遍历：先访问根节点，然后前序遍历左子树，最后后序遍历右子树。算法显然为递归形式。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	System.out.print(<span class="string">&quot;PreOrder: &quot;</span>);</span><br><span class="line">	preOrder(root);</span><br><span class="line">	System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode&lt;T&gt; node)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 确保&quot;#&quot;不被遍历</span></span><br><span class="line">	<span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; node.getData() != <span class="string">&quot;#&quot;</span>) &#123;</span><br><span class="line">     <span class="comment">// 遍历根节点</span></span><br><span class="line">		System.out.print(node.getData() + <span class="string">&quot; --&gt; &quot;</span>);</span><br><span class="line">     <span class="comment">// 前序遍历左子树</span></span><br><span class="line">		preOrder(node.getLeft());</span><br><span class="line">     <span class="comment">// 前序遍历右子树</span></span><br><span class="line">		preOrder(node.getRight());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 中序遍历、后序遍历的思想与此类似，也是采用递归方法实现。</p>
<p>遍历实例： <img src="../medias/images/notes/p17.png" /> 前序遍历<span class="math inline">\((DLR)\)</span>：A --&gt; B --&gt; D--&gt; (此处没有根节点，没有左子树，遍历右子树) --&gt; G --&gt; (左子树遍历完毕，回溯到A节点) C (开始遍历右子树) --&gt; E (左子树) --&gt; F (右子树)</p>
<p>中序遍历<span class="math inline">\((LDR)\)</span>：(A --&gt; B --&gt; D --&gt; null(D_left)) D (遍历到的第一个节点是D) --&gt; G --&gt; B (遍历根节点) --&gt; A --&gt; E (对A的右子树也实行中序遍历) --&gt; C --&gt; F</p>
<p>后序遍历<span class="math inline">\((LRD)\)</span>：G (一直回溯) --&gt; D --&gt; B --&gt; E (开始遍历右子树) --&gt; F --&gt; C --&gt; A</p>
<h6 id="树的遍历以栈为辅助结构">树的遍历（以栈为辅助结构）</h6>
<p>pass</p>
<h6 id="构建一棵树以前序构建为例">构建一棵树（以前序构建为例）</h6>
<p>按照前序顺序将新的节点加入到树中。可修改原先前序遍历的递归算法得到。<br />
采用<code>#</code>法完成输入：如上面例子中的树，可通过以下的输入构建： <code>new String[] &#123;"A", "B", "D", "#", "G", "#", "#", "#", "C", "E", "#", "#", "F", "#", "#"&#125;</code>，其中，<code>#</code>表示该符号前面的节点下面无其它节点，没有子树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照前序顺序找到第一个为null的子节点，并插入数据</span></span><br><span class="line"> <span class="comment">// 由于需要将新节点与其父节点链接，故设置pareNode节点，来传递父节点</span></span><br><span class="line"> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// 插入成功后即变为true,用来保证算法只插入一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preInsert</span><span class="params">(TreeNode&lt;T&gt; node, TreeNode&lt;T&gt; pareNode, T data)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (flag) <span class="keyword">return</span>;</span><br><span class="line">   <span class="comment">// 若未成功插入过节点，找到第一个现节点为null的位置</span></span><br><span class="line">	<span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">// 若根节点为null</span></span><br><span class="line">		<span class="keyword">if</span> (pareNode == <span class="keyword">null</span>) root = <span class="keyword">new</span> TreeNode(data);</span><br><span class="line">     <span class="comment">// 按照前序顺序插入，先左后右</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (pareNode.getLeft() == <span class="keyword">null</span>)</span><br><span class="line">			pareNode.setLeft(<span class="keyword">new</span> TreeNode(data));</span><br><span class="line">		<span class="keyword">else</span> pareNode.setRight(<span class="keyword">new</span> TreeNode(data));</span><br><span class="line">		flag = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">   <span class="comment">// &quot;#&quot;号代表到这里树的构建终止</span></span><br><span class="line">	<span class="keyword">if</span> (node.getData() == <span class="string">&quot;#&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">   <span class="comment">// 前序递归调用该方法</span></span><br><span class="line">	preInsert(node.getLeft(), node, data);</span><br><span class="line">	preInsert(node.getRight(), node, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意： - 根节点的没有父节点，即<code>pareNode = null</code>。 - 递归的出口有三个：<code>flag</code>为<code>true</code>（已经成功前序插入过一个节点）、<code>node</code>为<code>null</code>（成功找到该插入节点的位置）、<code>node</code>的<code>data</code>为<code>#</code>（表示该树节点后没有节点，到这里就已经终止了，不必再对当前子树进行遍历）。</p>
<h6 id="最后的constructor">最后的<code>constructor</code></h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Tree</span><span class="params">(T[] objs)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objs.length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (flag) flag = <span class="keyword">false</span>;</span><br><span class="line">		preInsert(root, <span class="keyword">null</span>, objs[i]);</span><br><span class="line">	&#125;			</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构建完毕。全部代码见后。</p>
<h4 id="测试树的构建">测试树的构建</h4>
<p>在<code>main</code>方法中运行以下代码，构建示例里的树，并进行遍历： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tree&lt;String&gt; tree = <span class="keyword">new</span> Tree&lt;String&gt;(<span class="keyword">new</span> String[] &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;#&quot;</span>, <span class="string">&quot;G&quot;</span>, <span class="string">&quot;#&quot;</span>, <span class="string">&quot;#&quot;</span>, <span class="string">&quot;#&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;#&quot;</span>, <span class="string">&quot;#&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="string">&quot;#&quot;</span>, <span class="string">&quot;#&quot;</span>&#125;);</span><br><span class="line">tree.preOrder();</span><br><span class="line">tree.inOrder();</span><br><span class="line">tree.postOrder();</span><br></pre></td></tr></table></figure> 运行结果： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[OUTPUT]: </span><br><span class="line">PreOrder: A --&gt; B --&gt; D --&gt; G --&gt; C --&gt; E --&gt; F --&gt;</span><br><span class="line">InOrder: D --&gt; G --&gt; B --&gt; A --&gt; E --&gt; C --&gt; F --&gt;</span><br><span class="line">PostOrder: G --&gt; D --&gt; B --&gt; E --&gt; F --&gt; C --&gt; A --&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="树类以及树节点类完整代码">树类（以及树节点类）完整代码</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> TreeNode&lt;T&gt; root;</span><br><span class="line">	<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Tree</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Tree</span><span class="params">(T rootData)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.root = <span class="keyword">new</span> TreeNode(rootData);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Tree</span><span class="params">(T[] objs)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objs.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (flag) flag = <span class="keyword">false</span>;</span><br><span class="line">			preInsert(root, <span class="keyword">null</span>, objs[i]);</span><br><span class="line">		&#125;			</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按照前序顺序找到第一个为null的子节点，并插入数据</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preInsert</span><span class="params">(TreeNode&lt;T&gt; node, TreeNode&lt;T&gt; pareNode, T data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (flag) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pareNode == <span class="keyword">null</span>) root = <span class="keyword">new</span> TreeNode(data);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (pareNode.getLeft() == <span class="keyword">null</span>)</span><br><span class="line">				pareNode.setLeft(<span class="keyword">new</span> TreeNode(data));</span><br><span class="line">			<span class="keyword">else</span> pareNode.setRight(<span class="keyword">new</span> TreeNode(data));</span><br><span class="line">			flag = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (node.getData() == <span class="string">&quot;#&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">		preInsert(node.getLeft(), node, data);</span><br><span class="line">		preInsert(node.getRight(), node, data);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Traversals algorithm ------ 遍历算法 --------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;PreOrder: &quot;</span>);</span><br><span class="line">		preOrder(root);</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode&lt;T&gt; node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; node.getData() != <span class="string">&quot;#&quot;</span>) &#123;</span><br><span class="line">			System.out.print(node.getData() + <span class="string">&quot; --&gt; &quot;</span>);</span><br><span class="line">			preOrder(node.getLeft());</span><br><span class="line">			preOrder(node.getRight());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;InOrder: &quot;</span>);</span><br><span class="line">		inOrder(root);</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode&lt;T&gt; node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; node.getData() != <span class="string">&quot;#&quot;</span>) &#123;</span><br><span class="line">			inOrder(node.getLeft());</span><br><span class="line">			System.out.print(node.getData() + <span class="string">&quot; --&gt; &quot;</span>);</span><br><span class="line">			inOrder(node.getRight());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;PostOrder: &quot;</span>);</span><br><span class="line">		postOrder(root);</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode&lt;T&gt; node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; node.getData() != <span class="string">&quot;#&quot;</span>) &#123;</span><br><span class="line">			postOrder(node.getLeft());</span><br><span class="line">			postOrder(node.getRight());</span><br><span class="line">			System.out.print(node.getData() + <span class="string">&quot; --&gt; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Tree&lt;String&gt; tree = <span class="keyword">new</span> Tree&lt;String&gt;(<span class="keyword">new</span> String[] &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;#&quot;</span>, <span class="string">&quot;G&quot;</span>, <span class="string">&quot;#&quot;</span>, <span class="string">&quot;#&quot;</span>, <span class="string">&quot;#&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;#&quot;</span>, <span class="string">&quot;#&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="string">&quot;#&quot;</span>, <span class="string">&quot;#&quot;</span>&#125;);</span><br><span class="line">		tree.preOrder();</span><br><span class="line">		tree.inOrder();</span><br><span class="line">		tree.postOrder();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode&lt;T&gt; <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(TreeNode&lt;T&gt; root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.root = root;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> flag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.flag = flag;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> T data;</span><br><span class="line">	<span class="keyword">private</span> TreeNode left;</span><br><span class="line">	<span class="keyword">private</span> TreeNode right;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data = data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data = data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> left;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(TreeNode left)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.left = left;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> right;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(TreeNode right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.right = right;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树binary-search-tree">二叉搜索树(Binary Search Tree)</h3>
<blockquote>
<p>A special type of binary tree called a binary search tree (BST) is often useful. A BST (with no duplicate elements) has the property that for every node in the tree, the value of any node in its left subtree is less than the value of the node, and the value of any node in its right subtree is greater than the value of the node.</p>
</blockquote>
<p>二叉搜索树：二叉搜索树(BST)是一种特殊而又实用的二叉树。BST（没有重复的节点）有着以下性质：对于树中的每个节点，左子树中任意节点储存的值 &lt; 该节点储存的值 &lt; 右子树中任意节点储存的值。 下图表示的就是一棵二叉搜索树。 <img src="../medias/images/notes/p18.png" /></p>
<h4 id="实用小技巧">实用小技巧</h4>
<ul>
<li><p>一棵二叉搜索树的必要条件是里面的元素可比较大小(即<code>Comaprable</code>)</p></li>
<li><p>二叉搜索树的递推方法：在二叉树中寻找值为<span class="math inline">\(ele\)</span>的节点。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  TreeNode&lt;T&gt; temp = root;</span><br><span class="line">  <span class="comment">// 直到temp的值等于ele为止</span></span><br><span class="line"><span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 若ele小于temp的值，左推节点</span></span><br><span class="line">	<span class="keyword">if</span> (ele.compareTo(temp.getData()) &lt; <span class="number">0</span>) temp = temp.getLeft();</span><br><span class="line">    <span class="comment">// 若ele大于temp的值，右推节点</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ele.compareTo(temp.getData()) &gt; <span class="number">0</span>) temp = temp.getRight();</span><br><span class="line">    <span class="comment">// ele 与当前节点相等</span></span><br><span class="line">	<span class="keyword">else</span> ......;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>如果还想对节点的父节点进行操作，可使用以下方式递推（将父节点也加入递推）： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TreeNode&lt;T&gt; pareNode = <span class="keyword">null</span>;</span><br><span class="line">TreeNode&lt;T&gt; temp = root;</span><br><span class="line"><span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (ele.compareTo(temp.getData()) == <span class="number">0</span>) &#123;...... </span><br><span class="line">    <span class="keyword">return</span>;&#125;</span><br><span class="line">          <span class="comment">// 将现节点赋值给父节点</span></span><br><span class="line">	pareNode = temp;</span><br><span class="line">	<span class="keyword">if</span> (ele.compareTo(temp.getData()) &lt; <span class="number">0</span>) temp = temp.getLeft();</span><br><span class="line">	<span class="keyword">else</span> temp = temp.getRight();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h4 id="二叉搜索树方法查找插入和删除">二叉搜索树方法（查找、插入和删除）</h4>
<h5 id="查找boolean-searcht-ele">查找<code>boolean search(T ele)</code></h5>
<p>即用上述递推方法，在树中寻找指定数值。若查找到，返回<code>true</code>；否则返回<code>false</code>。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在树中搜寻是否有指定元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(T ele)</span> </span>&#123;</span><br><span class="line">	TreeNode&lt;T&gt; temp = root;</span><br><span class="line">	<span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ele.compareTo(temp.getData()) &lt; <span class="number">0</span>) temp = temp.getLeft();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ele.compareTo(temp.getData()) &gt; <span class="number">0</span>) temp = temp.getRight();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="插入boolean-insertt-ele">插入<code>boolean insert(T ele)</code></h5>
<p>能够成功插入的条件是：BST内没有相同数值的节点。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把指定元素插入到合适的位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(T ele)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 带有父节点的递推</span></span><br><span class="line">       <span class="comment">// 用来寻找该插入的空位置</span></span><br><span class="line">	TreeNode&lt;T&gt; pareNode = <span class="keyword">null</span>;</span><br><span class="line">	TreeNode&lt;T&gt; temp = root;</span><br><span class="line">	<span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 重复的元素不再次插入</span></span><br><span class="line">		<span class="keyword">if</span> (ele.compareTo(temp.getData()) == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		pareNode = temp;</span><br><span class="line">		<span class="keyword">if</span> (ele.compareTo(temp.getData()) &lt; <span class="number">0</span>) temp = temp.getLeft();</span><br><span class="line">		<span class="keyword">else</span> temp = temp.getRight();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 考虑根节点为空的情况</span></span><br><span class="line">	<span class="keyword">if</span> (pareNode == <span class="keyword">null</span>) root = <span class="keyword">new</span> TreeNode&lt;T&gt;(ele);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 通过比较确定该插入的节点的位置</span></span><br><span class="line">		<span class="keyword">if</span> (ele.compareTo(pareNode.getData()) &lt; <span class="number">0</span>) pareNode.setLeft(<span class="keyword">new</span> TreeNode(ele));</span><br><span class="line">		<span class="keyword">else</span> pareNode.setRight(<span class="keyword">new</span> TreeNode(ele));</span><br><span class="line">	&#125;</span><br><span class="line">	size++;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="删除deletet-ele">删除<code>delete(T ele)</code></h5>
<p>删除操作比较复杂。不仅要考虑到怎样寻找该删除的元素，还要考虑删除后的连接问题，使得该树仍为二叉搜索树。<br />
删除操作：<br />
(1). 若该节点无左子树：将其第一个右节点连接到其父结点上（要考虑父节点是否为null）<br />
(2). 若该节点有左子树，则将左子树中最右节点（即最左子树中最大节点）连接到其父节点上。实际上，由于该节点为叶子节点，只需直接删除该节点；应删除节点位置不变，只需将其中元素替换为左子树最右节点元素即可。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从树中删除指定元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(T ele)</span> </span>&#123;</span><br><span class="line">	TreeNode&lt;T&gt; pareNode = <span class="keyword">null</span>;</span><br><span class="line">	TreeNode&lt;T&gt; temp = root;</span><br><span class="line">	<span class="comment">// 先找到指定元素及其父节点</span></span><br><span class="line">	<span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ele.compareTo(temp.getData()) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		pareNode = temp;</span><br><span class="line">		<span class="keyword">if</span> (ele.compareTo(temp.getData()) &lt; <span class="number">0</span>) temp = temp.getLeft();</span><br><span class="line">		<span class="keyword">else</span> temp = temp.getRight();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//树中查找不到指定数值，返回false</span></span><br><span class="line">	<span class="keyword">if</span> (temp == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 由于后面会有子节点，故进行连接操作而不是替换操作</span></span><br><span class="line">	<span class="comment">// 由于是连接操作，所以需要确定pare是否为null</span></span><br><span class="line">	<span class="keyword">if</span> (temp.getLeft() == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pareNode == <span class="keyword">null</span>) root = root.getRight();</span><br><span class="line">		<span class="comment">// 下面2行本质上是在确定temp的位置</span></span><br><span class="line">		<span class="keyword">if</span> (ele.compareTo(pareNode.getData()) &lt; <span class="number">0</span>) pareNode.setLeft(temp.getRight());</span><br><span class="line">		<span class="keyword">else</span> pareNode.setRight(temp.getRight());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 寻找左子树的最右节点，连接到父节点上去</span></span><br><span class="line">		TreeNode&lt;T&gt; pareOfRightMost = temp;</span><br><span class="line">		TreeNode&lt;T&gt; rightMost = temp.getLeft();</span><br><span class="line">		<span class="keyword">while</span> (rightMost.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			pareOfRightMost = rightMost;</span><br><span class="line">			rightMost = rightMost.getRight();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 由于是替换操作，故不需要确定pare的状态</span></span><br><span class="line">		<span class="keyword">if</span> (pareOfRightMost == temp) &#123;</span><br><span class="line">			temp.setData(rightMost.getData());</span><br><span class="line">			temp.setLeft(<span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			temp.setData(rightMost.getData());</span><br><span class="line">			pareNode.setRight(temp.getLeft());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	size--;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="二叉搜索树运行实例">二叉搜索树运行实例</h4>
<p>编写如下的一棵二叉搜索树，并对其进行前序/中序/后序遍历。 <img src="../medias/images/notes/p19.png" /><br />
<code>main</code>方法如下所示： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	BSTree&lt;Integer&gt; tree = <span class="keyword">new</span> BSTree&lt;Integer&gt;(<span class="keyword">new</span> Integer[]&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;);</span><br><span class="line">	tree.preOrder();</span><br><span class="line">	tree.inOrder();</span><br><span class="line">	tree.postOrder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 运行结果： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[OUTPUT]: </span><br><span class="line">PreOrder: <span class="number">2</span> --&gt; <span class="number">1</span> --&gt; <span class="number">4</span> --&gt; <span class="number">3</span> --&gt; <span class="number">8</span> --&gt; <span class="number">5</span> --&gt; <span class="number">6</span> --&gt; <span class="number">7</span> --&gt;</span><br><span class="line">InOrder: <span class="number">1</span> --&gt; <span class="number">2</span> --&gt; <span class="number">3</span> --&gt; <span class="number">4</span> --&gt; <span class="number">5</span> --&gt; <span class="number">6</span> --&gt; <span class="number">7</span> --&gt; <span class="number">8</span> --&gt;</span><br><span class="line">PostOrder: <span class="number">1</span> --&gt; <span class="number">3</span> --&gt; <span class="number">7</span> --&gt; <span class="number">6</span> --&gt; <span class="number">5</span> --&gt; <span class="number">8</span> --&gt; <span class="number">4</span> --&gt; <span class="number">2</span> --&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="二叉搜索树bst完整代码">二叉搜索树(BST)完整代码</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dataStructureRewrite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTree</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> TreeNode&lt;T&gt; root;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BSTree</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BSTree</span><span class="params">(T rootData)</span> </span>&#123;</span><br><span class="line">		root = <span class="keyword">new</span> TreeNode&lt;T&gt;(rootData);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BSTree</span><span class="params">(T[] objs)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (T obj : objs) </span><br><span class="line">			insert(obj);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 在树中搜寻是否有指定元素</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(T ele)</span> </span>&#123;</span><br><span class="line">		TreeNode&lt;T&gt; temp = root;</span><br><span class="line">		<span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ele.compareTo(temp.getData()) &lt; <span class="number">0</span>) temp = temp.getLeft();</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (ele.compareTo(temp.getData()) &gt; <span class="number">0</span>) temp = temp.getRight();</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 把指定元素插入到合适的位置</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(T ele)</span> </span>&#123;</span><br><span class="line">		TreeNode&lt;T&gt; pareNode = <span class="keyword">null</span>;</span><br><span class="line">		TreeNode&lt;T&gt; temp = root;</span><br><span class="line">		<span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 重复的元素不再次插入</span></span><br><span class="line">			<span class="keyword">if</span> (ele.compareTo(temp.getData()) == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			pareNode = temp;</span><br><span class="line">			<span class="keyword">if</span> (ele.compareTo(temp.getData()) &lt; <span class="number">0</span>) temp = temp.getLeft();</span><br><span class="line">			<span class="keyword">else</span> temp = temp.getRight();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pareNode == <span class="keyword">null</span>) root = <span class="keyword">new</span> TreeNode&lt;T&gt;(ele);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (ele.compareTo(pareNode.getData()) &lt; <span class="number">0</span>) pareNode.setLeft(<span class="keyword">new</span> TreeNode(ele));</span><br><span class="line">			<span class="keyword">else</span> pareNode.setRight(<span class="keyword">new</span> TreeNode(ele));</span><br><span class="line">		&#125;</span><br><span class="line">		size++;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 从树中删除指定元素</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(T ele)</span> </span>&#123;</span><br><span class="line">		TreeNode&lt;T&gt; pareNode = <span class="keyword">null</span>;</span><br><span class="line">		TreeNode&lt;T&gt; temp = root;</span><br><span class="line">		<span class="comment">// 先找到指定元素及其父节点</span></span><br><span class="line">		<span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ele.compareTo(temp.getData()) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">			pareNode = temp;</span><br><span class="line">			<span class="keyword">if</span> (ele.compareTo(temp.getData()) &lt; <span class="number">0</span>) temp = temp.getLeft();</span><br><span class="line">			<span class="keyword">else</span> temp = temp.getRight();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (temp == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 由于后面会有子节点，故进行连接操作而不是替换操作</span></span><br><span class="line">		<span class="comment">// 由于是连接操作，所以需要确定pare是否为null</span></span><br><span class="line">		<span class="keyword">if</span> (temp.getLeft() == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pareNode == <span class="keyword">null</span>) root = root.getRight();</span><br><span class="line">			<span class="comment">// 下面2行本质上是在确定temp的位置</span></span><br><span class="line">			<span class="keyword">if</span> (ele.compareTo(pareNode.getData()) &lt; <span class="number">0</span>) pareNode.setLeft(temp.getRight());</span><br><span class="line">			<span class="keyword">else</span> pareNode.setRight(temp.getRight());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 寻找左子树的最右节点，连接到父节点上去</span></span><br><span class="line">			TreeNode&lt;T&gt; pareOfRightMost = temp;</span><br><span class="line">			TreeNode&lt;T&gt; rightMost = temp.getLeft();</span><br><span class="line">			<span class="keyword">while</span> (rightMost.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				pareOfRightMost = rightMost;</span><br><span class="line">				rightMost = rightMost.getRight();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 由于是替换操作，故不需要确定pare的状态</span></span><br><span class="line">			<span class="keyword">if</span> (pareOfRightMost == temp) &#123;</span><br><span class="line">				temp.setData(rightMost.getData());</span><br><span class="line">				temp.setLeft(<span class="keyword">null</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				temp.setData(rightMost.getData());</span><br><span class="line">				pareNode.setRight(temp.getLeft());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		size--;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">			</span><br><span class="line">	<span class="comment">// Traversals algorithm ------ 遍历算法 --------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;PreOrder: &quot;</span>);</span><br><span class="line">		preOrder(root);</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode&lt;T&gt; node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.print(node.getData() + <span class="string">&quot; --&gt; &quot;</span>);</span><br><span class="line">			preOrder(node.getLeft());</span><br><span class="line">			preOrder(node.getRight());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;InOrder: &quot;</span>);</span><br><span class="line">		inOrder(root);</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode&lt;T&gt; node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">			inOrder(node.getLeft());</span><br><span class="line">			System.out.print(node.getData() + <span class="string">&quot; --&gt; &quot;</span>);</span><br><span class="line">			inOrder(node.getRight());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;PostOrder: &quot;</span>);</span><br><span class="line">		postOrder(root);</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode&lt;T&gt; node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">			postOrder(node.getLeft());</span><br><span class="line">			postOrder(node.getRight());</span><br><span class="line">			System.out.print(node.getData() + <span class="string">&quot; --&gt; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> size;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		root = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		BSTree&lt;Integer&gt; tree = <span class="keyword">new</span> BSTree&lt;Integer&gt;(<span class="keyword">new</span> Integer[]&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;);</span><br><span class="line">		tree.preOrder();</span><br><span class="line">		tree.inOrder();</span><br><span class="line">		tree.postOrder();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>TODO: 栈结构实现树的遍历/创建； 根据前/中/后遍历复原二叉树</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Java/" rel="tag"># -[数据结构] -[Java]</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/11/28/manim_wave/" rel="prev" title="【Manim】 绘制音乐波形图">
      <i class="fa fa-chevron-left"></i> 【Manim】 绘制音乐波形图
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0"><span class="nav-number">1.</span> <span class="nav-text">《数据结构》课程笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.1.</span> <span class="nav-text">算法时间复杂度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80"><span class="nav-number">1.1.1.</span> <span class="nav-text">数学基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.1.2.</span> <span class="nav-text">算法时间复杂度分析实例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B0-%E7%83%AD%E8%BA%AB"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">例0: 热身</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B1"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">例1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B2"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">例2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B3"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">例3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B4"><span class="nav-number">1.1.2.5.</span> <span class="nav-text">例4</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">1.1.3.</span> <span class="nav-text">递归算法的时间复杂度分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">1.2.1.</span> <span class="nav-text">两种基本排序：冒泡排序与选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%E7%9A%84%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">改进的冒泡排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%A0%B7%E4%BE%8B"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">冒泡排序运行样例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%E7%9A%84%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">改进的选择排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%A0%B7%E4%BE%8B"><span class="nav-number">1.2.1.6.</span> <span class="nav-text">选择排序运行样例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">1.2.2.</span> <span class="nav-text">插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">算法概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">时间复杂度分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%A0%B7%E4%BE%8B"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">插入排序运行样例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E9%93%BE%E8%A1%A8%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="nav-number">1.3.</span> <span class="nav-text">线性结构（链表、栈与队列）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">1.3.1.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#node%E8%8A%82%E7%82%B9%E7%B1%BB"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">Node节点类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E5%BE%80%E5%90%8E%E9%80%92%E6%8E%A8%E7%9A%84%E5%86%99%E6%B3%95"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">链表往后递推的写法：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">链表结构及各种方法的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#linkedlist-linkedlistt-constructor%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84tostring%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.1.3.1.</span> <span class="nav-text">LinkedList(), LinkedList(T[]) (constructor方法),以及一个简单的toString()方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A2%9E%E5%8A%A0%E8%8A%82%E7%82%B9%E6%96%B9%E6%B3%95addaddfirstinsertint-t"><span class="nav-number">1.3.1.3.2.</span> <span class="nav-text">增加节点方法add()、addFirst()、insert(int, T)：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A7%BB%E9%99%A4%E8%8A%82%E7%82%B9%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%89%E7%A7%8D%E5%86%99%E6%B3%95removetbooleanremoveintvoidremoveint"><span class="nav-number">1.3.1.3.3.</span> <span class="nav-text">移除节点方法的三种写法remove(T)、(boolean)remove(int)、(void)remove(int)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">完整代码：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">1.3.2.</span> <span class="nav-text">栈</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.2.0.1.</span> <span class="nav-text">栈结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BA%E6%A0%88%E8%BF%9B%E6%A0%88%E6%96%B9%E6%B3%95pushpop"><span class="nav-number">1.3.2.0.2.</span> <span class="nav-text">出栈、进栈方法push()、pop()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#tostring%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.2.0.3.</span> <span class="nav-text">toString()方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E4%B8%8E%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C"><span class="nav-number">1.3.2.0.4.</span> <span class="nav-text">运行与测试结果</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E5%BB%BA%E6%A0%88"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">链表建栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E5%BB%BA%E6%A0%88%E6%96%B9%E5%BC%8F%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">两种建栈方式完整代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%B1%E6%95%B0%E7%BB%84%E5%BB%BA%E6%A0%88"><span class="nav-number">1.3.2.2.1.</span> <span class="nav-text">由数组建栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%B1%E9%93%BE%E8%A1%A8%E5%BB%BA%E6%A0%88"><span class="nav-number">1.3.2.2.2.</span> <span class="nav-text">由链表建栈</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">1.3.3.</span> <span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E8%8A%82%E7%82%B9%E5%88%9B%E5%BB%BA%E9%98%9F%E5%88%97"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">通过节点创建队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">1.3.3.1.1.</span> <span class="nav-text">队列的遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BA%E9%98%9F%E4%B8%8E%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.3.1.2.</span> <span class="nav-text">出队与入队操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#size%E4%B8%8Etostring%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.3.1.3.</span> <span class="nav-text">size()与toString()方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E5%8F%8A%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="nav-number">1.3.3.1.4.</span> <span class="nav-text">运行及输出结果</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E9%93%BE%E8%A1%A8%E5%88%9B%E5%BB%BA%E9%98%9F%E5%88%97"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">通过链表创建队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E4%B8%A4%E4%B8%AA%E6%A0%88stack%E5%88%9B%E5%BB%BA%E9%98%9F%E5%88%97"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">通过两个栈(Stack)创建队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#stack"><span class="nav-number">1.3.3.3.1.</span> <span class="nav-text">Stack()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#enqueuedeqeueu%E5%85%A5%E9%98%9F%E5%88%97%E5%87%BA%E9%98%9F%E5%88%97%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.3.3.2.</span> <span class="nav-text">enQueue()、deQeueu()入队列、出队列方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sizetostring%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.3.3.3.</span> <span class="nav-text">size()、toString()方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">三种创建方法完整代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E8%8A%82%E7%82%B9%E5%88%9B%E5%BB%BA"><span class="nav-number">1.3.3.4.1.</span> <span class="nav-text">通过节点创建</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E9%93%BE%E8%A1%A8%E5%88%9B%E5%BB%BA"><span class="nav-number">1.3.3.4.2.</span> <span class="nav-text">通过链表创建</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%88%9B%E5%BB%BA"><span class="nav-number">1.3.3.4.3.</span> <span class="nav-text">通过两个栈创建</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E6%A0%91%E5%9B%BE"><span class="nav-number">1.4.</span> <span class="nav-text">非线性结构（树、图）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">1.4.1.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">树的性质</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8A%82%E7%82%B9%E4%B8%8E%E8%B7%AF%E5%BE%84"><span class="nav-number">1.4.1.2.1.</span> <span class="nav-text">节点与路径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%AB%98%E5%BA%A6%E4%B8%8E%E6%B7%B1%E5%BA%A6"><span class="nav-number">1.4.1.2.2.</span> <span class="nav-text">高度与深度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.4.1.2.3.</span> <span class="nav-text">二叉树的定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-number">1.4.1.2.4.</span> <span class="nav-text">二叉树的性质</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.4.1.2.5.</span> <span class="nav-text">满二叉树与完全二叉树</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">树的构建</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">1.4.1.3.1.</span> <span class="nav-text">数组表示法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8A%82%E7%82%B9%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">1.4.1.3.2.</span> <span class="nav-text">节点表示法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%91%E8%8A%82%E7%82%B9treenode%E7%B1%BB"><span class="nav-number">1.4.1.3.2.1.</span> <span class="nav-text">树节点TreeNode类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.1.3.2.2.</span> <span class="nav-text">树的遍历（递归方法）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E4%BB%A5%E6%A0%88%E4%B8%BA%E8%BE%85%E5%8A%A9%E7%BB%93%E6%9E%84"><span class="nav-number">1.4.1.3.2.3.</span> <span class="nav-text">树的遍历（以栈为辅助结构）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E4%B8%80%E6%A3%B5%E6%A0%91%E4%BB%A5%E5%89%8D%E5%BA%8F%E6%9E%84%E5%BB%BA%E4%B8%BA%E4%BE%8B"><span class="nav-number">1.4.1.3.2.4.</span> <span class="nav-text">构建一棵树（以前序构建为例）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%80%E5%90%8E%E7%9A%84constructor"><span class="nav-number">1.4.1.3.2.5.</span> <span class="nav-text">最后的constructor</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">测试树的构建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%B1%BB%E4%BB%A5%E5%8F%8A%E6%A0%91%E8%8A%82%E7%82%B9%E7%B1%BB%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="nav-number">1.4.1.5.</span> <span class="nav-text">树类（以及树节点类）完整代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91binary-search-tree"><span class="nav-number">1.4.2.</span> <span class="nav-text">二叉搜索树(Binary Search Tree)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">实用小技巧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">二叉搜索树方法（查找、插入和删除）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E6%89%BEboolean-searcht-ele"><span class="nav-number">1.4.2.2.1.</span> <span class="nav-text">查找boolean search(T ele)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8F%92%E5%85%A5boolean-insertt-ele"><span class="nav-number">1.4.2.2.2.</span> <span class="nav-text">插入boolean insert(T ele)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A0%E9%99%A4deletet-ele"><span class="nav-number">1.4.2.2.3.</span> <span class="nav-text">删除delete(T ele)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%90%E8%A1%8C%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">二叉搜索树运行实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91bst%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">二叉搜索树(BST)完整代码</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ponster"
      src="/images/mine/Attack.png">
  <p class="site-author-name" itemprop="name">Ponster</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ponster</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
